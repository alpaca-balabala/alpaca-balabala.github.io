<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[【笔记】Python基础篇（二）字符串和字符编码]]></title>
      <url>/2017/08/15/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91Python%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
      <content type="html"><![CDATA[<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="http://upload-images.jianshu.io/upload_images/4101271-caf670be7370fa9e.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></p>
<h2 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>1 bit（位）： 0 或 1 两种可能</li>
<li>1 byte（字节）： 8 bit = 2<sup>8</sup>种可能</li>
<li>ASCII：1个字节（8位）；英文字符 + 常见符号</li>
<li>Unicode：2个字节（16位）；字符集（万国码）<ol>
<li>变长编码方式UTF-8：英文1个字节；中文3个字节；生僻字符4-6个字节</li>
<li>变长编码方式UTF-16：统一2个字节</li>
</ol>
</li>
</ul>
<h3 id="什么是编码？"><a href="#什么是编码？" class="headerlink" title="什么是编码？"></a>什么是编码？</h3><p>基本概念很简单。首先，我们从一段信息即消息说起，消息以人类可以理解、易懂的表示存在。我打算将这种表示称为“明文”（plain text）。对于说英语的人，纸张上打印的或屏幕上显示的英文单词都算作明文。</p>
<p>其次，我们需要能将明文表示的消息转成另外某种表示，我们还需要能将编码文本转回成明文。从明文到编码文本的转换称为“编码”，从编码文本又转回成明文则为“解码”。</p>
<pre><code>编码问题是个大问题，如果不彻底解决，它就会像隐藏在丛林中的小蛇，时不时地咬你一口。
    那么到底什么是编码呢？

    //ASCII

    记住一句话：计算机中的所有数据，不论是文字、图片、视频、还是音频文件，本质上最终都是按照类似 01010101 的二进制存储的。
    再说简单点，计算机只懂二进制数字！
    所以，目的明确了：如何将我们能识别的符号唯一的与一组二进制数字对应上？于是美利坚的同志想到通过一个电平的高低状态来代指0或1，
    八个电平做为一组就可以表示出
    256种不同状态，每种状态就唯一对应一个字符，比如A---&gt;00010001,而英文只有26个字符，算上一些特殊字符和数字，128个状态也够
    用了；每个电平称为一个比特为，约定8个比特位构成一个字节，这样计算机就可以用127个不同字节来存储英语的文字了。这就是ASCII编码。

    扩展ANSI编码
    刚才说了，最开始，一个字节有八位，但是最高位没用上，默认为0；后来为了计算机也可以表示拉丁文，就将最后一位也用上了，
    从128到255的字符集对应拉丁文啦。至此，一个字节就用满了！

    //GB2312

    计算机漂洋过海来到中国后，问题来了，计算机不认识中文，当然也没法显示中文；而且一个字节所有状态都被占满了，万恶的帝国主义亡
    我之心不死啊！我党也是棒，自力更生，自己重写一张表，直接生猛地将扩展的第八位对应拉丁文全部删掉，规定一个小于127的字符的意
    义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到0xF7，后面一个字节
   （低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了；这种汉字方案叫做 “GB2312”。GB2312 是对 ASCII 的中文扩展。

    //GBK 和 GB18030编码

    但是汉字太多了，GB2312也不够用，于是规定：只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的
    内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。

    //UNICODE编码：

    很多其它国家都搞出自己的编码标准，彼此间却相互不支持。这就带来了很多问题。于是，国际标谁化组织为了统一编码：提出了标准编码准
    则：UNICODE 。
    UNICODE是用两个字节来表示为一个字符，它总共可以组合出65535不同的字符，这足以覆盖世界上所有符号（包括甲骨文）

    //utf8:

    unicode都一统天下了，为什么还要有一个utf8的编码呢？
    大家想，对于英文世界的人们来讲，一个字节完全够了，比如要存储A,本来00010001就可以了，现在吃上了unicode的大锅饭，
    得用两个字节：00000000 00010001才行，浪费太严重！
    基于此，美利坚的科学家们提出了天才的想法：utf8.
    UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码，它可以使用1~4个字节表示一个符号，根据
    不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，所以是兼容ASCII编码的。

    这样显著的好处是，虽然在我们内存中的数据都是unicode，但当数据要保存到磁盘或者用于网络传输时，直接使用unicode就远不如utf8省空间啦！
    这也是为什么utf8是我们的推荐编码方式。
</code></pre><p><strong>Unicode与utf8的关系：</strong></p>
<blockquote>
<p>一言以蔽之：Unicode是内存编码表示方案（是规范），而UTF是如何保存和传输Unicode的方案（是实现）这也是UTF与Unicode的区别。使用utf8：一切都是为了节省你的硬盘和流量。</p>
</blockquote>
<h3 id="Python2的字符编码"><a href="#Python2的字符编码" class="headerlink" title="Python2的字符编码"></a>Python2的字符编码</h3><p>在py2中，有两种字符串类型：str类型和unicode类型；注意，这仅仅是两个名字，python定义的两个名字，关键是这两种数据类型在程序运行时存在内存地址的是什么？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="string">'邵'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(s1))</div><div class="line">&lt;type <span class="string">'str'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(repr(s1))</div><div class="line"><span class="string">'\xe9\x82\xb5'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">u'邵'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(s2))</div><div class="line">&lt;type <span class="string">'unicode'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(repr(s2))</div><div class="line"><span class="string">u'\u90b5'</span></div></pre></td></tr></table></figure>
<p>内置函数repr可以帮我们在这里显示存储内容。原来，str和unicode分别存的是字节数据和unicode数据；那么两种数据之间是什么关系呢？如何转换呢?这里就涉及到编码(encode)和解码(decode)了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="string">u'邵'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> repr(s1)</div><div class="line"><span class="string">u'\u90b5'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = s1.encode(<span class="string">'utf8'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> type(b)</div><div class="line">&lt;type <span class="string">'str'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> repr(b)</div><div class="line"><span class="string">'\xe9\x82\xb5'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">'邵奇'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>u = s2.decode(<span class="string">'utf8'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> u</div><div class="line">邵奇</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> type(u)</div><div class="line">&lt;type <span class="string">'unicode'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> repr(u)</div><div class="line"><span class="string">u'\u90b5\u5947'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>u2 = s2.decode(<span class="string">'gbk'</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">UnicodeDecodeError: <span class="string">'gbk'</span> codec can<span class="string">'t decode bytes in position 4-5: illegal multibyte sequence</span></div></pre></td></tr></table></figure></p>
<p>无论是utf8还是gbk都只是一种编码规则，一种把unicode数据编码成字节数据的规则，所以utf8编码的字节一定要用utf8的规则解码，否则就会出现乱码或者报错的情况。</p>
<p><strong>Python2编码的特色：</strong><br>Python 2 悄悄掩盖掉了 byte 到 unicode 的转换，只要数据全部是 ASCII 的话，所有的转换都是正确的，一旦一个非 ASCII 字符偷偷进入你的程序，那么默认的解码将会失效，从而造成 UnicodeDecodeError 的错误。py2编码让程序在处理 ASCII 的时候更加简单。你复出的代价就是在处理非 ASCII 的时候将会失败。</p>
<h3 id="Python3的字符编码"><a href="#Python3的字符编码" class="headerlink" title="Python3的字符编码"></a>Python3的字符编码</h3><p>py3也有两种数据类型：str和bytes；  str类型存unicode数据，bytse类型存bytes数据，与py2比只是换了一下名字而已。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'邵奇'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(s))</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></div><div class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(json.dumps<span class="params">(s)</span>)</span></span></div><div class="line"><span class="class">"\<span class="title">u90b5</span>\<span class="title">u5947</span>"</span></div><div class="line">&gt;&gt;&gt; b = s.encode('utf8')</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(b))</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">bytes</span>'&gt;</span></div><div class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(b)</span></span></div><div class="line"><span class="class"><span class="title">b</span>'\<span class="title">xe9</span>\<span class="title">x82</span>\<span class="title">xb5</span>\<span class="title">xe5</span>\<span class="title">xa5</span>\<span class="title">x87</span>'</span></div><div class="line">&gt;&gt;&gt; u = b.decode('utf8')</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(u))</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></div><div class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(u)</span></span></div><div class="line"><span class="class">邵奇</span></div></pre></td></tr></table></figure>
<p><strong>Python3的编码哲学：</strong><br>Python 3最重要的新特性大概要算是对文本和二进制数据作了更为清晰的区分，不再会对bytes字节串进行自动解码。文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。Python 3不会以任意隐式的方式混用str和bytes，正是这使得两者的区分特别清晰。你不能拼接字符串和字节包，也无法在字节包里搜索字符串（反之亦然），也不能将字符串传入参数为字节包的函数（反之亦然）。</p>
<p><em>注意：无论py2，还是py3,与明文直接对应的就是unicode数据，打印unicode数据就会显示相应的明文(包括英文和中文)</em></p>
<h3 id="文件从磁盘到内存的编码"><a href="#文件从磁盘到内存的编码" class="headerlink" title="文件从磁盘到内存的编码"></a>文件从磁盘到内存的编码</h3><p>说到这，才来到我们的重点！</p>
<p>抛开执行执行程序，请问大家，文本编辑器大家都是用过吧，如果不懂是什么，那么word总用过吧，ok，当我们在word上编辑文字的时候，不管是中文还是英文，计算机都是不认识的，那么在保存之前数据是通过什么形式存在内存的呢？yes，就是unicode数据，为什么要存unicode数据，这是因为它的名字最屌：万国码！解释起来就是无论英文，中文，日文，拉丁文，世界上的任何字符它都有唯一编码对应，所以兼容性是最好的。</p>
<p>好，那当我们保存了存到磁盘上的数据又是什么呢？</p>
<p>答案是通过某种编码方式编码的bytes字节串。比如utf8-－－一种可变长编码，很好的节省了空间；当然还有历史产物的gbk编码等等。于是，在我们的文本编辑器软件都有默认的保存文件的编码方式，比如utf8，比如gbk。当我们点击保存的时候，这些编辑软件已经”默默地”帮我们做了编码工作。</p>
<p>那当我们再打开这个文件时，软件又默默地给我们做了解码的工作，将数据再解码成unicode,然后就可以呈现明文给用户了！所以，unicode是离用户更近的数据，bytes是离计算机更近的数据。</p>
<p>说了这么多，和我们程序执行有什么关系呢？</p>
<p>先明确一个概念：py解释器本身就是一个软件，一个类似于文本编辑器一样的软件！</p>
<p>现在让我们一起还原一个py文件从创建到执行的编码过程：</p>
<p>打开pycharm，创建hello.py文件，写入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s = <span class="string">'帅得一逼'</span></div><div class="line">print(s)</div></pre></td></tr></table></figure></p>
<p>当我们保存的的时候，hello.py文件就以pycharm默认的编码方式保存到了磁盘；关闭文件后再打开，pycharm就再以默认的编码方式对该文件打开后读到的内容进行解码，转成unicode到内存我们就看到了我们的明文；</p>
<p>而如果我们点击运行按钮或者在命令行运行该文件时，py解释器这个软件就会被调用，打开文件，然后解码存在磁盘上的bytes数据成unicode数据，这个过程和编辑器是一样的，不同的是解释器会再将这些unicode数据翻译成C代码再转成二进制的数据流，最后通过控制操作系统调用cpu来执行这些二进制数据，整个过程才算结束。</p>
<p>那么问题来了，我们的文本编辑器有自己默认的编码解码方式，我们的解释器有吗？</p>
<p>当然有啦，py2默认ASCII码，py3默认的utf8，可以通过如下方式查询</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line">print(sys.getdefaultencoding())</div></pre></td></tr></table></figure>
<p>是的，这就是因为如果py2解释器去执行一个utf8编码的文件，就会以默认地ASCII去解码utf8，一旦程序中有中文，自然就解码错误了，所以我们在文件开头位置声明　<code>#coding:utf8</code>，其实就是告诉解释器，你不要以默认的编码方式去解码这个文件，而是以utf8来解码。而py3的解释器因为默认utf8编码，所以就方便很多了。</p>
<p><em>注意：我们上面讲的string编码是在cpu执行程序时的存储状态，是另外一个过程，不要混淆！</em></p>
<h3 id="常见的编码问题"><a href="#常见的编码问题" class="headerlink" title="常见的编码问题"></a>常见的编码问题</h3><p><strong>1 cmd下的乱码问题</strong></p>
<p>文件保存时的编码也为utf8。</p>
<p>思考：为什么在IDE下用2或3执行都没问题，在cmd.exe下3正确，2乱码呢？</p>
<p>我们在win下的终端即cmd.exe去执行，大家注意，cmd.exe本身也一个软件；当我们python2 hello.py时，python2解释器(默认ASCII编码)去按声明的utf8编码文件，而文件又是utf8保存的，所以没问题；问题出在当我们print’苑昊’时，解释器这边正常执行，也不会报错，只是print的内容会传递给cmd.exe用来显示，而在py2里这个内容就是utf8编码的字节数据，可这个软件默认的编码解码方式是GBK，所以cmd.exe用GBK的解码方式去解码utf8自然会乱码。</p>
<p>py3正确的原因是传递给cmd的是unicode数据，cmd.exe可以识别内容，所以显示没问题。</p>
<p>明白原理了，修改就有很多方式，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">u'你好'</span>)</div></pre></td></tr></table></figure></p>
<p>改成这样后，cmd下用2也不会有问题了。</p>
<p><strong>2 open()中的编码问题</strong><br>创建一个hello文本，保存成utf8：</p>
<pre><code>你好，大傻逼！
</code></pre><p>同目录下创建一个index.py同目录下创建一个index.py</p>
<pre><code>f=open(&apos;hello&apos;)
print(f.read())
</code></pre><p>为什么 在linux下，结果正常：“你好，大傻逼！”，在win下，乱码（py3解释器）？</p>
<p>因为你的win的操作系统安装时是默认的gbk编码，而linux操作系统默认的是utf8编码；</p>
<p>当执行open函数时，调用的是操作系统打开文件，操作系统用默认的gbk编码去解码utf8的文件，自然乱码。</p>
<p>解决办法：</p>
<pre><code>f=open(&apos;hello&apos;,encoding=&apos;utf8&apos;)
print(f.read())
</code></pre><p>如果你的文件保存的是gbk编码，在win 下就不用指定encoding了。</p>
<p>另外，如果你的win上不需要指定给操作系统encoding=’utf8’，那就是你安装时就是默认的utf8编码或者已经通过命令修改成了utf8编码。</p>
<p><em>注意：open这个函数在py2里和py3中是不同的，py3中有了一个encoding＝None参数。</em></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><ul>
<li>标准类型比较操作符：按照ASCII值比较大小</li>
<li>cmp函数（python3中取消）,按照ASCII值比较大小</li>
</ul>
<p>Python 3.X 的版本中已经没有 cmp 函数，如果你需要实现比较功能，需要引入 operator 模块，适合任何对象，包含的方法有：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">operator.lt(a, b)    <span class="comment">#  小于</span></div><div class="line">operator.le(a, b)    <span class="comment">#  小于等于</span></div><div class="line">operator.eq(a, b)    <span class="comment">#  等于</span></div><div class="line">operator.ne(a, b)    <span class="comment">#  不等于</span></div><div class="line">operator.ge(a, b)    <span class="comment">#  大于等于</span></div><div class="line">operator.gt(a, b)    <span class="comment">#  大于</span></div><div class="line">operator.__lt__(a, b)</div><div class="line">operator.__le__(a, b)</div><div class="line">operator.__eq__(a, b)</div><div class="line">operator.__ne__(a, b)</div><div class="line">operator.__ge__(a, b)</div><div class="line">operator.__gt__(a, b)</div></pre></td></tr></table></figure>
<h3 id="BIF（Built-in-Function）"><a href="#BIF（Built-in-Function）" class="headerlink" title="BIF（Built-in Function）"></a>BIF（Built-in Function）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dir(str)    <span class="comment">#  查看str所有BIF</span></div></pre></td></tr></table></figure>
<p><strong>更改显示方式：</strong></p>
<ul>
<li>大小写</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">capitalize()    <span class="comment"># 首字母大写，其余小写</span></div><div class="line">title()         <span class="comment"># 每个单词首字母大写</span></div><div class="line">upper()         <span class="comment"># 全大写</span></div><div class="line">lower()         <span class="comment"># 全小写</span></div><div class="line">swapcase()      <span class="comment"># 反转大小写</span></div></pre></td></tr></table></figure>
<ul>
<li>宽度</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">center(width)    <span class="comment"># 居中</span></div><div class="line">ljust(width)     <span class="comment"># 左对齐</span></div><div class="line">rjust(width)     <span class="comment"># 右对齐，以上空格填充至width，也可传入第二个参数，为填充的内容</span></div><div class="line">zfill(width)     <span class="comment"># 前面用0填充至width长度</span></div></pre></td></tr></table></figure>
<ul>
<li>编码</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">encode(<span class="string">"utf-8"</span>)    <span class="comment"># 编码</span></div><div class="line">decode(<span class="string">"utf-8"</span>)    <span class="comment"># 解码</span></div></pre></td></tr></table></figure>
<p><strong>检查：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">count(str,beg,end)  </div><div class="line"><span class="comment"># 统计str出现次数，beg,end可选参数指定范围</span></div><div class="line">find(str,beg,end)/rfind(str,beg,end)  </div><div class="line"><span class="comment"># 判断是否有str,如果有返回索引值，否则返回-1</span></div><div class="line">index(str,beg,end)/rindex(strbeg,end)  </div><div class="line"><span class="comment"># 跟find一样，只不过找不到str会报错</span></div><div class="line">endswith(str,beg,end)/startswith(str,beg,end)  </div><div class="line"><span class="comment"># 检查是否以str开头或结尾</span></div><div class="line">isalnum()  </div><div class="line"><span class="comment"># 如果string至少有一个字符并且所有字符都是字母或数字则返回True,否则返回False</span></div><div class="line">isalpha()</div><div class="line"><span class="comment"># 如果string至少有一个字符并且所有字符都是字母则返回True,否则返回False</span></div><div class="line">isdecimal()</div><div class="line"><span class="comment"># 如果string只包含十进制数字则返回True否则返回False.</span></div><div class="line">isdigit()</div><div class="line"><span class="comment"># 如果string只包含数字则返回True否则返回False.</span></div><div class="line">isnumeric()</div><div class="line"><span class="comment"># 如果string中只包含数字字符，则返回True，否则返回False</span></div><div class="line">islower()</div><div class="line"><span class="comment"># 如果string中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回True，否则返回False</span></div><div class="line">isupper()</div><div class="line"><span class="comment"># 如果string中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回True，否则返回False</span></div><div class="line">istitle()</div><div class="line"><span class="comment"># 如果string是所有单词都是以大写开始，其余字母均为小写，则返回True，否则返回False</span></div><div class="line">isspace()</div><div class="line"><span class="comment"># 如果string中只包含空格，则返回True，否则返回False.</span></div></pre></td></tr></table></figure>
<p><em><code>is数字</code>系列详解：</em></p>
<ul>
<li>isdigt:bytes,unicode</li>
<li>isdecimal:uncicode</li>
<li>isnumberic:unicode,中文数字,罗马数字</li>
<li>三者不能判断浮点数</li>
<li>总结：最常用的是<code>isdigit</code>,可以判断<code>bytes</code>和<code>unicode</code>类型,这也是最常见的数字应用场景。如果要判断中文数字或罗马数字,则需要用到<code>isnumeric</code></li>
</ul>
<p><strong>修改：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">expandtabs()</div><div class="line"><span class="comment"># 把字符串string中的tab符号转为空格，tab符号默认的空格数是8。</span></div><div class="line">replace(str1, str2,num)</div><div class="line"><span class="comment"># 把string中的str1替换成str2,如果num 指定，则替换不超过string.count(str1)次.</span></div><div class="line">strip()</div><div class="line"><span class="comment"># 删除string字符串左右两边的空格</span></div><div class="line">lstrip()</div><div class="line"><span class="comment"># 截掉string左边的空格</span></div><div class="line">rstrip()</div><div class="line"><span class="comment"># 删除string字符串末尾的空格.</span></div><div class="line">split(str,num)</div><div class="line"><span class="comment"># 以str为分隔符切片string，如果num有指定值，则仅分隔num个子字符串</span></div><div class="line">splitlines([keepends])</div><div class="line"><span class="comment"># 按照行('\r', '\r\n', \n')分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</span></div><div class="line">partition(str)</div><div class="line"><span class="comment"># 有点像 find()和split()的结合体,从str出现的第一个位置起,把字符串string分成一个3元素的元组(string_pre_str,str,string_post_str),如果string中不包含str 则string_pre_str == string</span></div><div class="line">rpartition(str)</div><div class="line"><span class="comment"># 类似于 partition()函数,不过是从右边开始查找.</span></div><div class="line">join(seq)</div><div class="line"><span class="comment"># 以string作为分隔符，将seq中所有的元素(的字符串表示)合并为一个新的字符串,seq为可迭代的，必须都是字符串</span></div></pre></td></tr></table></figure>
<p><strong>其他：</strong></p>
<ul>
<li>maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</li>
<li>translate() 方法根据参数table给出的表(包含 256 个字符)转换字符串的字符, 要过滤掉的字符放到 del 参数中。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># translate使用实例</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> string <span class="keyword">import</span> maketrans   <span class="comment"># 引用 maketrans 函数。</span></div><div class="line"></div><div class="line">intab = <span class="string">"aeiou"</span></div><div class="line">outtab = <span class="string">"12345"</span></div><div class="line">trantab = maketrans(intab, outtab)</div><div class="line"></div><div class="line">str = <span class="string">"this is string example....wow!!!"</span>;</div><div class="line"><span class="keyword">print</span> str.translate(trantab);</div></pre></td></tr></table></figure>
<p>输出结果为：th3s 3s str3ng 2x1mpl2….w4w!!!</p>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。</p>
<p><strong>格式化操作符%</strong></p>
<p>格式：<code>%[(name)][flags][width].[precision]typecode</code><br>内涵：</p>
<pre><code>(name)：可选，用于选择指定的key
flags：可选，可供选择的值有:
    + ：右对齐；正数前加正好，负数前加负号；
    - ：左对齐；正数前无符号，负数前加负号；
    空格 ：右对齐；正数前加空格，负数前加负号；
    0 ：右对齐；正数前无符号，负数前加负号；用0填充空白处
width：可选，占有宽度
.precision：可选，小数点后保留的位数
typecode：必选：
    s，获取传入对象的__str__方法的返回值，并将其格式化到指定位置
    r，获取传入对象的__repr__方法的返回值，并将其格式化到指定位置
    c，整数：将数字转换成其unicode对应的值，10进制范围为 0 &lt;= i &lt;= 1114111（py27则只支持0-255）；字符：将字符添加到指定位置
    o，将整数转换成 八  进制表示，并将其格式化到指定位置
    x，将整数转换成十六进制表示，并将其格式化到指定位置
    d，将整数、浮点数转换成 十 进制表示，并将其格式化到指定位置
    e，将整数、浮点数转换成科学计数法，并将其格式化到指定位置（小写e）
    E，将整数、浮点数转换成科学计数法，并将其格式化到指定位置（大写E）
    f， 将整数、浮点数转换成浮点数表示，并将其格式化到指定位置（默认保留小数点后6位）
    F，同上
    g，自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过6位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是e；）
    G，自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过6位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是E；）
    %，当字符串中存在格式化标志时，需要用 %%表示一个百分号
</code></pre><p><strong>格式化字符串format</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">res1 = <span class="string">'&#123;&#125;&#123;&#125;&#123;&#125;'</span>.format(<span class="string">'shaoqi'</span>,<span class="number">18</span>,<span class="string">'male'</span>)    <span class="comment"># 不设置指定位置，按默认顺序</span></div><div class="line">res2 = <span class="string">'&#123;1&#125;&#123;0&#125;&#123;1&#125;'</span>.format(<span class="string">'shaoqi'</span>,<span class="number">18</span>,<span class="string">'male'</span>)    <span class="comment"># 位置参数</span></div><div class="line">res3 = <span class="string">'&#123;name&#125;&#123;sex&#125;&#123;age&#125;'</span>.format(sex=<span class="string">'male'</span>,name=<span class="string">'shaoqi'</span>,age=<span class="number">18</span>)    <span class="comment"># 关键字参数</span></div></pre></td></tr></table></figure>
<p>注：数字格式化的format方法参见：<a href="http://www.runoob.com/python/att-string-format.html" target="_blank" rel="external">http://www.runoob.com/python/att-string-format.html</a></p>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【笔记】Python基础篇（一）数据类型]]></title>
      <url>/2017/08/14/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91Python%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="http://upload-images.jianshu.io/upload_images/4101271-2910ac26266ef0ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><ul>
<li>变量存储在内存中的值。这就意味着在创建变量时会在内存中开辟一个空间。</li>
<li>基于变量的数据类型，解释器会分配指定内存，并决定什么数据可以被存储在内存中。</li>
<li>因此，变量可以指定不同的数据类型，这些变量可以存储整数，小数或字符。</li>
</ul>
<h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><ul>
<li>Python 中的变量赋值不需要类型声明。</li>
<li>每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。</li>
<li>每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</li>
<li>等号（=）用来给变量赋值。</li>
<li>等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。</li>
</ul>
<h3 id="多个变量赋值"><a href="#多个变量赋值" class="headerlink" title="多个变量赋值"></a>多个变量赋值</h3><p>Python允许你同时为多个变量赋值。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = b = c = <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">"john"</span></div></pre></td></tr></table></figure></p>
<p>以上实例，两个整型对象1和2的分配给变量 a 和 b，字符串对象 “john” 分配给变量 c。</p>
<h2 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h2><h3 id="数字（Numbers）"><a href="#数字（Numbers）" class="headerlink" title="数字（Numbers）"></a>数字（Numbers）</h3><ul>
<li>数字数据类型用于存储数值。</li>
<li>他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。</li>
</ul>
<p><strong>整型</strong><br>Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样。</p>
<p>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用<code>0x</code>前缀和0-9，a-f表示，例如：<code>0xff00</code>，<code>0xa5b4c3d2</code>，等等。</p>
<p><strong>浮点型</strong><br>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10<sup>9</sup>和12.3x10<sup>8</sup>是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10<sup>9</sup>就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。</p>
<p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。故浮点数不能直接比大小！</p>
<p><strong>布尔型</strong></p>
<ul>
<li>True</li>
<li>False</li>
</ul>
<p><strong>复数</strong><br>Python还支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型</p>
<h3 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h3><p><em>字符串或串(String)是由数字、字母、下划线组成的一串字符。<br>它是编程语言中表示文本的数据类型。</em></p>
<p>python的字串列表有2种取值顺序:</p>
<ul>
<li>从左到右索引默认0开始的，最大范围是字符串长度少1</li>
<li>从右到左索引默认-1开始的，最大范围是字符串开头</li>
</ul>
<p>如果你要实现从字符串中获取一段子字符串的话，可以使用变量 <code>[头下标:尾下标]</code>，就可以截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，<code>下标可以为空表示取到头或尾</code>。</p>
<p>加号<code>+</code>是字符串连接运算符，星号<code>*</code>是重复操作。</p>
<h3 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h3><ul>
<li>List（列表） 是 Python 中使用最频繁的数据类型。</li>
<li>列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。</li>
<li>列表用 <code>[ ]</code> 标识，是 python 最通用的复合数据类型。</li>
<li>列表中值的切割也可以用到变量 <code>[头下标:尾下标]</code> ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。</li>
<li>加号 <code>+</code> 是列表连接运算符，星号 <code>*</code> 是重复操作</li>
</ul>
<h3 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h3><ul>
<li>元组是另一个数据类型，类似于List（列表）。</li>
<li>元组用<code>()</code>标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。</li>
</ul>
<h3 id="字典（Dictionary）"><a href="#字典（Dictionary）" class="headerlink" title="字典（Dictionary）"></a>字典（Dictionary）</h3><ul>
<li>字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象结合，字典是无序的对象集合。</li>
<li>两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</li>
<li>字典用<code>{ }</code>标识。字典由索引(key)和它对应的值value组成。</li>
</ul>
<h3 id="集合（Sets）-非标准数据类型"><a href="#集合（Sets）-非标准数据类型" class="headerlink" title="集合（Sets）(非标准数据类型)"></a>集合（Sets）(非标准数据类型)</h3><ul>
<li>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</li>
<li>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作。</li>
<li>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。<strong><em>原因：key必须是【可哈希】的，而不可变对象均可哈希。如果是元组，其中只能包括不可变类型。</em></strong></li>
</ul>
<h2 id="其它数据类型"><a href="#其它数据类型" class="headerlink" title="其它数据类型"></a>其它数据类型</h2><p><strong>空值</strong><br>空值是Python里一个特殊的值，用<code>None</code>表示。<code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</p>
<h2 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h2><p><strong>按存值个数区分：</strong></p>
<table>
<thead>
<tr>
<th>标量/原子类型</th>
<th>数字、字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>容器类型</td>
<td>列表、元组、字典、集合</td>
</tr>
</tbody>
</table>
<p><strong>按可变不可变区分：</strong></p>
<table>
<thead>
<tr>
<th>可变</th>
<th>列表、字典、集合</th>
</tr>
</thead>
<tbody>
<tr>
<td>不可变</td>
<td>数字、字符串、元组</td>
</tr>
</tbody>
</table>
<p><strong>按访问顺序区分：</strong></p>
<table>
<thead>
<tr>
<th>直接访问</th>
<th>数字</th>
</tr>
</thead>
<tbody>
<tr>
<td>顺序访问（序列类型）</td>
<td>字符串、列表、元组</td>
</tr>
<tr>
<td>key值访问（映射类型）</td>
<td>字典</td>
</tr>
</tbody>
</table>
<h2 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h2><p><img src="../../../../images/2017-08-14/QQ截图20170814102641.png" alt=""></p>
<h2 id="标准类型操作符"><a href="#标准类型操作符" class="headerlink" title="标准类型操作符"></a>标准类型操作符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><img src="../../../../images/2017-08-14/QQ截图20170814095650.png" alt=""></p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p><img src="../../../../images/2017-08-14/QQ截图20170814100003.png" alt=""></p>
<h3 id="比较（关系）运算符"><a href="#比较（关系）运算符" class="headerlink" title="比较（关系）运算符"></a>比较（关系）运算符</h3><p><img src="../../../../images/2017-08-14/QQ截图20170814095854.png" alt=""></p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p><img src="../../../../images/2017-08-14/QQ截图20170814100058.png" alt=""></p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><img src="../../../../images/2017-08-14/QQ截图20170814100326.png" alt=""></p>
<h3 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h3><p><img src="../../../../images/2017-08-14/QQ截图20170814100352.png" alt=""></p>
<h3 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h3><p><img src="../../../../images/2017-08-14/QQ截图20170814100430.png" alt=""></p>
<p><strong>is 与 == 区别：</strong><br>is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = a       <span class="comment">#  b引用a，二者指向同一块内存地址</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b == a</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = a[:]    <span class="comment">#  尽管b的值与a相同，但切片操作返回一个新的对象</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b == a</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure></p>
<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p><img src="../../../../images/2017-08-14/QQ截图20170814101504.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【笔记】二、进程与线程]]></title>
      <url>/2017/08/12/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h3><ul>
<li>一个具有一定独立功能的程序对某个数据集合上的一次动态执行过程和资源分配过程</li>
<li>进程的元素：代码、数据、<strong>进程表</strong>（进程控制块） Code、Data、PT（<strong>PCB</strong>）</li>
<li>是<strong>资源分配的基本单位</strong></li>
</ul>
<h3 id="进程和程序的区别与联系"><a href="#进程和程序的区别与联系" class="headerlink" title="进程和程序的区别与联系"></a>进程和程序的区别与联系</h3><ul>
<li>进程是动态的，程序是静态的</li>
<li>进程是暂时的，程序是永久的</li>
<li>进程和程序的组成不同<ul>
<li>程序主要包含代码和数据</li>
<li>进程除了包含代码和数据以外，还有进程表</li>
</ul>
</li>
<li>进程和程序间有非常紧密的联系<ul>
<li>程序经过多次创建，可以对应不同的进程</li>
<li>一个进程通过系统调用，可以被多个程序所使用</li>
</ul>
</li>
</ul>
<h3 id="进程特征"><a href="#进程特征" class="headerlink" title="进程特征"></a>进程特征</h3><p>动态性、并发性、独立性、异步性（提高利用率）</p>
<h3 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h3><p><strong>状态：</strong></p>
<ul>
<li>运行状态（Running）</li>
<li>阻塞状态（Blocked）</li>
<li>就绪状态（Ready）</li>
</ul>
<p><strong>转换：</strong></p>
<ol>
<li>运行状态→阻塞状态</li>
<li>运行状态→就绪状态</li>
<li>就绪状态→运行状态</li>
<li>阻塞状态→就绪状态<br><img src="../../../../images/2017-08-12/QQ截图20170812125716.png" alt=""><br><img src="../../../../images/2017-08-12/QQ截图20170812130314.png" alt=""><br><img src="../../../../images/2017-08-12/QQ截图20170812130526.png" alt=""></li>
</ol>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p><strong>进程创建</strong></p>
<blockquote>
<p>进程创建原语的主要工作是：首先查找系统的 PCB 表，查询有无空的 PCB<br>表项，如有，则申请一个，并对其进程初始化。初始化的项目有进程标识符（PID）、进程状态和运行程序的起始地址等；如果申请不成功，则返回创建失败信息。创建完成后，将进程表插入到就绪队列中。</p>
</blockquote>
<p><strong>进程创建的典型事件</strong></p>
<ul>
<li>用户登录</li>
<li>作业调度</li>
<li>提供服务</li>
<li>应用请求</li>
</ul>
<p><strong>进程的创建过程</strong></p>
<ul>
<li>申请空白进程表</li>
<li>为新进程分配资源</li>
<li>初始化进程表</li>
<li>如果进程就绪队列能够接纳新进程， 便将新进程插入就绪队列</li>
</ul>
<p><strong>进程撤销</strong></p>
<blockquote>
<p>撤销原语的主要工作是：首先检查 PCB 链表，寻找所要撤销的进程是否存在。如果找到了相应的表项后，撤销原语就释放该进程占用的资源并回收对应的PCB 数据结构。如果被撤销的进程还有子进程，则进程撤销原语必须先撤销子进程的 PCB 并释放其所占用的资源。</p>
</blockquote>
<ul>
<li>正常结束（自愿的）</li>
<li>异常结束<ul>
<li>普通错误退出（自愿的）</li>
<li>致命错误退出（非自愿的）</li>
</ul>
</li>
<li>外界干预（非自愿的）</li>
</ul>
<p><strong>进程阻塞</strong></p>
<blockquote>
<p>进程阻塞原语的运行：先停止处理机并同时保存该进程的处理机现场。然后将阻塞进程插入到等待队列中，再将控制权交给调度程序，调度程序会按调度算法从就绪队列中选择一个进程投入运行。</p>
</blockquote>
<p><strong>进程唤醒</strong></p>
<blockquote>
<p>唤醒原语工作：将被唤醒的进程从相应的等待队列移出，并将其 PCB 中状<br>态置为就绪态，并将其送入就绪队列。此时，唤醒原语既可以从调用程序处直接返回，也可以转向进程调度程序，由调度程序来选择一个合适的进程去运行。</p>
<p>一个进程由运行状态转变为阻塞状态，是这个进程自己调用阻塞原语去完成<br>的，而进程由阻塞状态到就绪状态，却是另一个进程调用唤醒原语实现的，一般情况下，这个进程与被唤醒进程是具有一定相关性的并发进程。</p>
</blockquote>
<p><strong>引起进程阻塞和唤醒的事件</strong></p>
<ul>
<li>请求系统服务</li>
<li>启动某种操作</li>
<li>新数据尚未到达</li>
<li>无新工作可做</li>
</ul>
<p><strong>进程挂起</strong></p>
<blockquote>
<p>挂起原语工作：将进程交换到外存交换区挂起，释放其在内存中占用的资源，改写 PCB，返回系统。</p>
</blockquote>
<p><strong>进程激活</strong></p>
<blockquote>
<p>激活原语工作：将进程从外存交换区调入内存（需要重新申请内存），进行<br>内存重定位，改写 PCB 进程状态信息，内存分配信息，程序计数器等，返回激活原语调用处。当激活后的进程处于就绪状态时，返回后控制权将交还给调度程序，重新调度。</p>
</blockquote>
<h3 id="进程组织"><a href="#进程组织" class="headerlink" title="进程组织"></a>进程组织</h3><p><strong>进程实体</strong><br><em>程序、数据集合、进程控制块（PCB）</em></p>
<ul>
<li>程序：也称正文，描述进程所要完成的功能，特指二进制的指令代码。</li>
<li>数据集合：程序运行所需要的数据结构。包括常数，变量，堆，数据栈等。</li>
<li>进程控制块：进程控制块包含了进程的描述信息、控制信息和资源信息，是进程动态特性的集中反映。</li>
</ul>
<p><strong>进程控制块 PCB：进程表 PT</strong></p>
<ul>
<li>进程控制信息<br>—进程的基本信息<br>—处理机管理信息</li>
<li>进程内存资源分配</li>
<li>进程设备和文件的分配和使用情况</li>
</ul>
<p><strong>进程控制块的组织</strong><br><em>链表方式、索引方式</em><br><img src="../../../../images/2017-08-12/QQ截图20170812132715.png" alt=""></p>
<p><strong>进程通信</strong></p>
<ul>
<li>进程通信：进程间的信息交换工作称为进程间的通信</li>
<li>P、V 操作称为低级通信</li>
<li>高级通信方式可分为三大类：共享内存、消息传递、管道机制</li>
<li>UNIX 通信还有信号（Signal）机制</li>
<li>网络通信还有套接字（Socket）</li>
</ul>
<p><strong>线程概念和多线程模型</strong></p>
<ul>
<li>线程的引入<br><img src="../../../../images/2017-08-12/QQ截图20170812133149.png" alt=""></li>
<li>线程的属性<ul>
<li>轻型实体（容易创建和撤销）</li>
<li><strong>独立调度和分派的基本单位</strong></li>
<li>可并发执行</li>
<li>共享进程资源</li>
<li>适应硬件的发展</li>
</ul>
</li>
<li>线程表<br><img src="../../../../images/2017-08-12/QQ截图20170812150537.png" alt=""></li>
<li><p>线程实体</p>
<blockquote>
<p>线程是进程中的一个实体，它是操作系统进行<strong>独立调度和分派的基本单位</strong>，但<strong>不是资源分配的基本单位</strong>。<br><img src="../../../../images/2017-08-12/QQ截图20170812150553.png" alt=""></p>
</blockquote>
</li>
<li><p>线程实现方式：线程在具体实现时形式上又分为内核线程和用户线程。</p>
</li>
<li>内核线程<br><img src="../../../../images/2017-08-12/QQ截图20170812134748.png" alt=""></li>
<li>用户线程<br><img src="../../../../images/2017-08-12/QQ截图20170812134857.png" alt=""></li>
<li>多线程模型<br><img src="../../../../images/2017-08-12/QQ截图20170812134955.png" alt=""><br>注：轻量级进程——只含有一个线程的进程</li>
</ul>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="调度的基本概念"><a href="#调度的基本概念" class="headerlink" title="调度的基本概念"></a>调度的基本概念</h3><p><strong>调度的基本概念</strong></p>
<blockquote>
<p>进程的数量多于处理机的个数，竞争处理机。分配处理机的任务由进程调度<br>程序完成，由进程分派程序具体实行。用一定的算法，动态地把处理机分配给进程，使之能公平、合理和高效地运行。调度是分层次的。—个作业从提交开始，直到完成，往往要经历多级调度。</p>
</blockquote>
<p><img src="../../../../images/2017-08-12/QQ截图20170812135957.png" alt=""></p>
<p><strong>作业调度</strong></p>
<blockquote>
<p>作业调度又称宏观调度或高级调度。其主要任务是按一定的原则，对外存储器中处于后备状态的作业进行选择。</p>
</blockquote>
<p><strong>进程调度</strong></p>
<blockquote>
<p>进程调度又称微观调度，是指决定就绪队列中哪个进程将获得处理机，并实<br>际将处理机分配给该进程的操作。</p>
<p>进程调度是操作系统中最基本的调度。调度过程体现了现代操作系统将策略与机制分离的设计思想，调度考虑的是选择进程的算法，并将算法选择提供给用户使用；而<strong>分派程序</strong>是机制，它是直接进行处理机切换的操作者。</p>
</blockquote>
<p><del><strong>交换调度：</strong>交换调度又称中级调度。</del>（内存中研究的）</p>
<p><img src="../../../../images/2017-08-12/QQ截图20170812140517.png" alt=""></p>
<p><strong>调度目标和准则</strong></p>
<ul>
<li>公平性：确保每个进程都能公平地获得处理机的机会</li>
<li>高效性：尽可能使处理机的利用率达到 100%</li>
<li>响应时间：对交互式系统要求有符合用户习惯的响应时间</li>
<li>吞吐量：单位时间内批处理系统所能完成的工作量</li>
</ul>
<h3 id="调度的时机、切换和过程"><a href="#调度的时机、切换和过程" class="headerlink" title="调度的时机、切换和过程"></a>调度的时机、切换和过程</h3><p><strong>1. 引起进程调度的典型事件：</strong></p>
<ul>
<li>正在运行的进程发生某事件而不能再继续运行</li>
<li>运行中的进程因提出输入/输出请求而暂停运行</li>
<li>在进程通信或同步过程中运行了某种原语操作，如 P 操作等</li>
<li>在可抢先式调度中，有一个比当前进程优先级更高的进程进入就绪队列</li>
<li>在时间片轮转算法中，时间片用完。</li>
</ul>
<p><strong>2. 分派程序（dispatcher）：</strong></p>
<ul>
<li>分派程序完成进程的切换，是实际操作者。</li>
<li>上下文切换</li>
</ul>
<h3 id="调度的基本准则"><a href="#调度的基本准则" class="headerlink" title="调度的基本准则"></a>调度的基本准则</h3><p><strong>调度的基本准则包括：</strong>处理机利用率、吞吐量、周转时间<br><strong>调度的基本名词解释：</strong>后备时间、等待时间、响应时间、带权周转时间</p>
<h3 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a>调度方式</h3><ul>
<li>不可抢先方式</li>
<li>可抢先方式</li>
</ul>
<h3 id="典型调度算法"><a href="#典型调度算法" class="headerlink" title="典型调度算法"></a>典型调度算法</h3><ul>
<li>先来先服务（FCFS）</li>
<li>短作业或短进（线）程优先（SJF&amp;SPF）</li>
<li>时间片轮转调度算法（RR）</li>
<li>高优先级优先调度算法</li>
<li>高响应比优先调度（HRRN）算法<blockquote>
<p>响应比 Rp =（等待时间+预计运行时间）/ 预计运行时间 = 响应时间 / 预计运行时间</p>
</blockquote>
</li>
<li>多级反馈队列调度算法</li>
</ul>
<h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><h3 id="同步与互斥的基本概念"><a href="#同步与互斥的基本概念" class="headerlink" title="同步与互斥的基本概念"></a>同步与互斥的基本概念</h3><p><strong>基本概念：</strong></p>
<ul>
<li>间接相互制约：源于资源共享-<strong>互斥</strong>。</li>
<li>直接相互制约：源于进程合作-<strong>同步</strong>。</li>
<li><strong>临界资源</strong>：一次只允许一个进程使用的资源称为临界资源</li>
<li><strong>临界区</strong>：在每个进程中，访问临界资源的那段程序称为临界区</li>
</ul>
<p><strong>同步与互斥机制应遵循的准则：</strong></p>
<ul>
<li>空闲则进</li>
<li>遇忙等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ul>
<h3 id="实现临界区互斥的基本方法"><a href="#实现临界区互斥的基本方法" class="headerlink" title="实现临界区互斥的基本方法"></a>实现临界区互斥的基本方法</h3><ul>
<li><strong>软件实现方法</strong></li>
<li><strong>硬件实现方法</strong></li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量：信号量的值是可变的，由初始化和 P、V 操作来改变。</p>
<blockquote>
<p>P（S）操作的定义：<br>–S.Q； //表示申请一个资源<br>if (S.Q &lt; 0) //若没有空闲资源<br>{<br> 调用进程进入等待队列 S.Q；<br> 阻塞调用进程；<br>}<br>V（S）操作的定义：<br>++S.Q； //表示释放一个资源<br>if (S.Q &lt;= 0) //若有进程处于阻塞状态<br>{<br> 从等待队列 S.Q 中取出一个进程 P；<br> 进程 P 进入就绪队列；}</p>
<p>P、V 操作实现互斥模型：<br>type def semaphore；<br>semaphore S=1；<br>PROC1 PROC2<br>P（S）； P（S）；<br> critical section critical section<br>V（S）； V（S）；<br> remainder section remainder section<br>P、V 操作实现同步模型：<br>type def semaphore；<br>semaphore S=0；<br>PROC1 PROC2<br> P（S）；<br> produce data； consume data；<br>V（S）；<br> remainder section remainder section</p>
</blockquote>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p><strong>管程：</strong>一个管程定义了一个数据结构和能为并发进程所运行的一组操作，这组操作能同步进程和改变管程中的数据。</p>
<h3 id="经典的同步问题"><a href="#经典的同步问题" class="headerlink" title="经典的同步问题"></a>经典的同步问题</h3><ul>
<li><strong>生产者-消费者问题</strong></li>
<li><strong>读者-写者问题</strong></li>
<li><strong>哲学家进餐问题</strong></li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p><strong>死锁：</strong></p>
<blockquote>
<p>系统中两个或两个以上的进程无限期地相互等待永远不会发生的条件，系统处于一种停滞状态，这种情况称为死锁。</p>
</blockquote>
<p><strong>死锁产生的原因：</strong></p>
<ul>
<li>进程推进顺序不当</li>
<li>对互斥资源的分配不当</li>
</ul>
<p><strong>产生死锁的四个必要条件：</strong></p>
<ul>
<li>互斥条件：任一时刻只允许一个进程使用资源。</li>
<li>非剥夺条件：进程已经占用的资源，不会被强制剥夺。</li>
<li>占用并请求条件：进程占有部分资源，并申请更多的资源，且不会主动释放已经占有的资源。</li>
<li>循环等待：请求资源的进程形成了循环。</li>
</ul>
<p><strong>死锁的处理策略：</strong></p>
<ul>
<li>忽略死锁。</li>
<li>锁的检测与恢复。</li>
<li>死锁的<strong>避免</strong>。</li>
<li>死锁的<strong>预防</strong>。</li>
</ul>
<p><strong>死锁预防：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">条件</th>
<th style="text-align:center">方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">互斥</td>
<td style="text-align:center">虚拟设备假脱机</td>
</tr>
<tr>
<td style="text-align:center">占有并等待</td>
<td style="text-align:center">一次分配全部资源</td>
</tr>
<tr>
<td style="text-align:center">非剥夺</td>
<td style="text-align:center">主动放弃</td>
</tr>
<tr>
<td style="text-align:center">循环等待</td>
<td style="text-align:center">有序分配资源</td>
</tr>
</tbody>
</table>
<p><strong>死锁避免：</strong></p>
<ul>
<li>安全状态</li>
<li>不安全状态</li>
</ul>
<p><strong>银行家算法：</strong>（实际系统中难以实现，很难事先声明需要多少资源）</p>
<blockquote>
<p>银行家算法问题描述是：一个银行家把他的固定资金借给若干顾客，使这些顾客能满足对资金的要求又能完成其交易，也使银行家可以收回全部的现金。只要不出现一个顾客借走所有资金后还不够、还需要借贷。则银行家的资金应是安全的，银行家需要一个算法保证借出去的资金在有限时间内可收回。</p>
</blockquote>
<h3 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h3><p><strong>死锁的检测与解除：</strong></p>
<ul>
<li>资源分配图算法</li>
<li>资源矩阵算法</li>
</ul>
<p><strong>死锁的解除：</strong></p>
<ul>
<li>资源剥夺法</li>
<li>进程撤销法</li>
<li>进程回退法</li>
<li>重新启动系统</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【笔记】一、操作系统概述]]></title>
      <url>/2017/08/11/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%80%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h2 id="操作系统的概念、特征、功能和提供的服务"><a href="#操作系统的概念、特征、功能和提供的服务" class="headerlink" title="操作系统的概念、特征、功能和提供的服务"></a>操作系统的概念、特征、功能和提供的服务</h2><h3 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h3><p>操作系统是控制和管理计算机软、硬件资源，以尽可能合理、高效的方法为<br>不同用户及其应用程序提供服务的一种系统程序。（即操作系统是一个软件）</p>
<ul>
<li>从用户使用角度看，既可以直接用命令控制，也可以通过系统调用编程实现。（人机交互桥梁）</li>
<li>从资源管理的角度来看，操作系统提高系统资源的利用率。（软硬件的管理者）</li>
<li>从发展的角度看，操作系统是一台虚拟机，它是计算机硬件的首次扩充，又是扩展机。</li>
</ul>
<h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><ul>
<li>并发（最基本特征）</li>
<li>共享</li>
<li>虚拟</li>
<li>不确定性</li>
</ul>
<p>注：并发是操作系统最基本的，后三点都是由并发引起的</p>
<h3 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3><ul>
<li>进程管理</li>
<li>存储管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
<h3 id="操作系统所能提供的服务"><a href="#操作系统所能提供的服务" class="headerlink" title="操作系统所能提供的服务"></a>操作系统所能提供的服务</h3><p>命令控制接口：命令行，GUI，脚本（批处理），NUI（nature user interface[如：语音识别]）<br>系统调用：创建、打开、读、写、关闭、删除</p>
<p>API（Application Programming Interface）是多个系统调用和部分代码的综合，比系统调用功能更加强大（高，有多个变种）</p>
<h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h2><h3 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h3><ul>
<li>大型计算机、巨型计算机</li>
<li>军用计算机、工业控制计算机能实时响应</li>
<li>嵌入式计算机要求精简、功能专一</li>
<li>便携式设备要求省电，电池持续耐力强</li>
</ul>
<h3 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h3><ul>
<li>单用户操作系统</li>
<li>批处理操作系统：单道批处理；多道批处理。脱机；联机</li>
<li>分时操作系统</li>
<li>实时系统：硬实时；软实时</li>
<li>网络操作系统</li>
<li>分布式操作系统</li>
<li>并行操作系统</li>
</ul>
<h2 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h2><h3 id="内核态与用户态"><a href="#内核态与用户态" class="headerlink" title="内核态与用户态"></a>内核态与用户态</h3><ul>
<li>操作系统运行的状态（特权指令：只允许在内核态下使用）</li>
<li>用户代码运行的状态（访管指令：由用户态进入到内核态时使用）</li>
</ul>
<p>注：任何一条系统调用的第一条指令都是访管指令，陷入到内核区</p>
<h3 id="中断、异常"><a href="#中断、异常" class="headerlink" title="中断、异常"></a>中断、异常</h3><ul>
<li>中断处理异步事件</li>
<li>异常（故障、<strong>陷阱</strong>、中止）（是一种软中断）</li>
</ul>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><ul>
<li>陷入机制（访管指令）</li>
<li>内核态</li>
</ul>
<p>现代操作系统除了提供直接使用系统调用指令的接口外，通常的做法是提供一套方便、实用的应用程序函数库（又称为应用程序设计接口 API）。这些函数从应用的较高层面重新封装了系统调用，一方面屏蔽了复杂的系统调用传参问题，另一方面是高级语言接口，有助于快速开发。还有的系统在更高层面提供了系统程序设计的模板库和类库。</p>
<h2 id="操作系统体系结构"><a href="#操作系统体系结构" class="headerlink" title="操作系统体系结构"></a>操作系统体系结构</h2><ul>
<li>整体式（无结构）</li>
<li>层次式</li>
<li>微内核（客户/服务器）</li>
<li>模块式（面向对象）</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
