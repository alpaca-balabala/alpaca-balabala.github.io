<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[【笔记】二、进程与线程]]></title>
      <url>/2017/08/12/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h3><ul>
<li>一个具有一定独立功能的程序对某个数据集合上的一次动态执行过程和资源分配过程</li>
<li>进程的元素：代码、数据、<strong>进程表</strong>（进程控制块） Code、Data、PT（<strong>PCB</strong>）</li>
<li>是<strong>资源分配的基本单位</strong></li>
</ul>
<h3 id="进程和程序的区别与联系"><a href="#进程和程序的区别与联系" class="headerlink" title="进程和程序的区别与联系"></a>进程和程序的区别与联系</h3><ul>
<li>进程是动态的，程序是静态的</li>
<li>进程是暂时的，程序是永久的</li>
<li>进程和程序的组成不同<ul>
<li>程序主要包含代码和数据</li>
<li>进程除了包含代码和数据以外，还有进程表</li>
</ul>
</li>
<li>进程和程序间有非常紧密的联系<ul>
<li>程序经过多次创建，可以对应不同的进程</li>
<li>一个进程通过系统调用，可以被多个程序所使用</li>
</ul>
</li>
</ul>
<h3 id="进程特征"><a href="#进程特征" class="headerlink" title="进程特征"></a>进程特征</h3><p>动态性、并发性、独立性、异步性（提高利用率）</p>
<h3 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h3><p><strong>状态：</strong></p>
<ul>
<li>运行状态（Running）</li>
<li>阻塞状态（Blocked）</li>
<li>就绪状态（Ready）</li>
</ul>
<p><strong>转换：</strong></p>
<ol>
<li>运行状态→阻塞状态</li>
<li>运行状态→就绪状态</li>
<li>就绪状态→运行状态</li>
<li>阻塞状态→就绪状态<br><img src="../../../../images/2017-08-12/QQ截图20170812125716.png" alt=""><br><img src="../../../../images/2017-08-12/QQ截图20170812130314.png" alt=""><br><img src="../../../../images/2017-08-12/QQ截图20170812130526.png" alt=""></li>
</ol>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p><strong>进程创建</strong></p>
<blockquote>
<p>进程创建原语的主要工作是：首先查找系统的 PCB 表，查询有无空的 PCB<br>表项，如有，则申请一个，并对其进程初始化。初始化的项目有进程标识符（PID）、进程状态和运行程序的起始地址等；如果申请不成功，则返回创建失败信息。创建完成后，将进程表插入到就绪队列中。</p>
</blockquote>
<p><strong>进程创建的典型事件</strong></p>
<ul>
<li>用户登录</li>
<li>作业调度</li>
<li>提供服务</li>
<li>应用请求</li>
</ul>
<p><strong>进程的创建过程</strong></p>
<ul>
<li>申请空白进程表</li>
<li>为新进程分配资源</li>
<li>初始化进程表</li>
<li>如果进程就绪队列能够接纳新进程， 便将新进程插入就绪队列</li>
</ul>
<p><strong>进程撤销</strong></p>
<blockquote>
<p>撤销原语的主要工作是：首先检查 PCB 链表，寻找所要撤销的进程是否存在。如果找到了相应的表项后，撤销原语就释放该进程占用的资源并回收对应的PCB 数据结构。如果被撤销的进程还有子进程，则进程撤销原语必须先撤销子进程的 PCB 并释放其所占用的资源。</p>
</blockquote>
<ul>
<li>正常结束（自愿的）</li>
<li>异常结束<ul>
<li>普通错误退出（自愿的）</li>
<li>致命错误退出（非自愿的）</li>
</ul>
</li>
<li>外界干预（非自愿的）</li>
</ul>
<p><strong>进程阻塞</strong></p>
<blockquote>
<p>进程阻塞原语的运行：先停止处理机并同时保存该进程的处理机现场。然后将阻塞进程插入到等待队列中，再将控制权交给调度程序，调度程序会按调度算法从就绪队列中选择一个进程投入运行。</p>
</blockquote>
<p><strong>进程唤醒</strong></p>
<blockquote>
<p>唤醒原语工作：将被唤醒的进程从相应的等待队列移出，并将其 PCB 中状<br>态置为就绪态，并将其送入就绪队列。此时，唤醒原语既可以从调用程序处直接返回，也可以转向进程调度程序，由调度程序来选择一个合适的进程去运行。</p>
<p>一个进程由运行状态转变为阻塞状态，是这个进程自己调用阻塞原语去完成<br>的，而进程由阻塞状态到就绪状态，却是另一个进程调用唤醒原语实现的，一般情况下，这个进程与被唤醒进程是具有一定相关性的并发进程。</p>
</blockquote>
<p><strong>引起进程阻塞和唤醒的事件</strong></p>
<ul>
<li>请求系统服务</li>
<li>启动某种操作</li>
<li>新数据尚未到达</li>
<li>无新工作可做</li>
</ul>
<p><strong>进程挂起</strong></p>
<blockquote>
<p>挂起原语工作：将进程交换到外存交换区挂起，释放其在内存中占用的资源，改写 PCB，返回系统。</p>
</blockquote>
<p><strong>进程激活</strong></p>
<blockquote>
<p>激活原语工作：将进程从外存交换区调入内存（需要重新申请内存），进行<br>内存重定位，改写 PCB 进程状态信息，内存分配信息，程序计数器等，返回激活原语调用处。当激活后的进程处于就绪状态时，返回后控制权将交还给调度程序，重新调度。</p>
</blockquote>
<h3 id="进程组织"><a href="#进程组织" class="headerlink" title="进程组织"></a>进程组织</h3><p><strong>进程实体</strong><br><em>程序、数据集合、进程控制块（PCB）</em></p>
<ul>
<li>程序：也称正文，描述进程所要完成的功能，特指二进制的指令代码。</li>
<li>数据集合：程序运行所需要的数据结构。包括常数，变量，堆，数据栈等。</li>
<li>进程控制块：进程控制块包含了进程的描述信息、控制信息和资源信息，是进程动态特性的集中反映。</li>
</ul>
<p><strong>进程控制块 PCB：进程表 PT</strong></p>
<ul>
<li>进程控制信息<br>—进程的基本信息<br>—处理机管理信息</li>
<li>进程内存资源分配</li>
<li>进程设备和文件的分配和使用情况</li>
</ul>
<p><strong>进程控制块的组织</strong><br><em>链表方式、索引方式</em><br><img src="../../../../images/2017-08-12/QQ截图20170812132715.png" alt=""></p>
<p><strong>进程通信</strong></p>
<ul>
<li>进程通信：进程间的信息交换工作称为进程间的通信</li>
<li>P、V 操作称为低级通信</li>
<li>高级通信方式可分为三大类：共享内存、消息传递、管道机制</li>
<li>UNIX 通信还有信号（Signal）机制</li>
<li>网络通信还有套接字（Socket）</li>
</ul>
<p><strong>线程概念和多线程模型</strong></p>
<ul>
<li>线程的引入<br><img src="../../../../images/2017-08-12/QQ截图20170812133149.png" alt=""></li>
<li>线程的属性<ul>
<li>轻型实体（容易创建和撤销）</li>
<li><strong>独立调度和分派的基本单位</strong></li>
<li>可并发执行</li>
<li>共享进程资源</li>
<li>适应硬件的发展</li>
</ul>
</li>
<li>线程表<br><img src="../../../../images/2017-08-12/QQ截图20170812150537.png" alt=""></li>
<li><p>线程实体</p>
<blockquote>
<p>线程是进程中的一个实体，它是操作系统进行<strong>独立调度和分派的基本单位</strong>，但<strong>不是资源分配的基本单位</strong>。<br><img src="../../../../images/2017-08-12/QQ截图20170812150553.png" alt=""></p>
</blockquote>
</li>
<li><p>线程实现方式：线程在具体实现时形式上又分为内核线程和用户线程。</p>
</li>
<li>内核线程<br><img src="../../../../images/2017-08-12/QQ截图20170812134748.png" alt=""></li>
<li>用户线程<br><img src="../../../../images/2017-08-12/QQ截图20170812134857.png" alt=""></li>
<li>多线程模型<br><img src="../../../../images/2017-08-12/QQ截图20170812134955.png" alt=""><br>注：轻量级进程——只含有一个线程的进程</li>
</ul>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="调度的基本概念"><a href="#调度的基本概念" class="headerlink" title="调度的基本概念"></a>调度的基本概念</h3><p><strong>调度的基本概念</strong></p>
<blockquote>
<p>进程的数量多于处理机的个数，竞争处理机。分配处理机的任务由进程调度<br>程序完成，由进程分派程序具体实行。用一定的算法，动态地把处理机分配给进程，使之能公平、合理和高效地运行。调度是分层次的。—个作业从提交开始，直到完成，往往要经历多级调度。</p>
</blockquote>
<p><img src="../../../../images/2017-08-12/QQ截图20170812135957.png" alt=""></p>
<p><strong>作业调度</strong></p>
<blockquote>
<p>作业调度又称宏观调度或高级调度。其主要任务是按一定的原则，对外存储器中处于后备状态的作业进行选择。</p>
</blockquote>
<p><strong>进程调度</strong></p>
<blockquote>
<p>进程调度又称微观调度，是指决定就绪队列中哪个进程将获得处理机，并实<br>际将处理机分配给该进程的操作。</p>
<p>进程调度是操作系统中最基本的调度。调度过程体现了现代操作系统将策略与机制分离的设计思想，调度考虑的是选择进程的算法，并将算法选择提供给用户使用；而<strong>分派程序</strong>是机制，它是直接进行处理机切换的操作者。</p>
</blockquote>
<p><del><strong>交换调度：</strong>交换调度又称中级调度。</del>（内存中研究的）</p>
<p><img src="../../../../images/2017-08-12/QQ截图20170812140517.png" alt=""></p>
<p><strong>调度目标和准则</strong></p>
<ul>
<li>公平性：确保每个进程都能公平地获得处理机的机会</li>
<li>高效性：尽可能使处理机的利用率达到 100%</li>
<li>响应时间：对交互式系统要求有符合用户习惯的响应时间</li>
<li>吞吐量：单位时间内批处理系统所能完成的工作量</li>
</ul>
<h3 id="调度的时机、切换和过程"><a href="#调度的时机、切换和过程" class="headerlink" title="调度的时机、切换和过程"></a>调度的时机、切换和过程</h3><p><strong>1. 引起进程调度的典型事件：</strong></p>
<ul>
<li>正在运行的进程发生某事件而不能再继续运行</li>
<li>运行中的进程因提出输入/输出请求而暂停运行</li>
<li>在进程通信或同步过程中运行了某种原语操作，如 P 操作等</li>
<li>在可抢先式调度中，有一个比当前进程优先级更高的进程进入就绪队列</li>
<li>在时间片轮转算法中，时间片用完。</li>
</ul>
<p><strong>2. 分派程序（dispatcher）：</strong></p>
<ul>
<li>分派程序完成进程的切换，是实际操作者。</li>
<li>上下文切换</li>
</ul>
<h3 id="调度的基本准则"><a href="#调度的基本准则" class="headerlink" title="调度的基本准则"></a>调度的基本准则</h3><p><strong>调度的基本准则包括：</strong>处理机利用率、吞吐量、周转时间<br><strong>调度的基本名词解释：</strong>后备时间、等待时间、响应时间、带权周转时间</p>
<h3 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a>调度方式</h3><ul>
<li>不可抢先方式</li>
<li>可抢先方式</li>
</ul>
<h3 id="典型调度算法"><a href="#典型调度算法" class="headerlink" title="典型调度算法"></a>典型调度算法</h3><ul>
<li>先来先服务（FCFS）</li>
<li>短作业或短进（线）程优先（SJF&amp;SPF）</li>
<li>时间片轮转调度算法（RR）</li>
<li>高优先级优先调度算法</li>
<li>高响应比优先调度（HRRN）算法<blockquote>
<p>响应比 Rp =（等待时间+预计运行时间）/ 预计运行时间 = 响应时间 / 预计运行时间</p>
</blockquote>
</li>
<li>多级反馈队列调度算法</li>
</ul>
<h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><h3 id="同步与互斥的基本概念"><a href="#同步与互斥的基本概念" class="headerlink" title="同步与互斥的基本概念"></a>同步与互斥的基本概念</h3><p><strong>基本概念：</strong></p>
<ul>
<li>间接相互制约：源于资源共享-<strong>互斥</strong>。</li>
<li>直接相互制约：源于进程合作-<strong>同步</strong>。</li>
<li><strong>临界资源</strong>：一次只允许一个进程使用的资源称为临界资源</li>
<li><strong>临界区</strong>：在每个进程中，访问临界资源的那段程序称为临界区</li>
</ul>
<p><strong>同步与互斥机制应遵循的准则：</strong></p>
<ul>
<li>空闲则进</li>
<li>遇忙等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ul>
<h3 id="实现临界区互斥的基本方法"><a href="#实现临界区互斥的基本方法" class="headerlink" title="实现临界区互斥的基本方法"></a>实现临界区互斥的基本方法</h3><ul>
<li><strong>软件实现方法</strong></li>
<li><strong>硬件实现方法</strong></li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量：信号量的值是可变的，由初始化和 P、V 操作来改变。</p>
<blockquote>
<p>P（S）操作的定义：<br>–S.Q； //表示申请一个资源<br>if (S.Q &lt; 0) //若没有空闲资源<br>{<br> 调用进程进入等待队列 S.Q；<br> 阻塞调用进程；<br>}<br>V（S）操作的定义：<br>++S.Q； //表示释放一个资源<br>if (S.Q &lt;= 0) //若有进程处于阻塞状态<br>{<br> 从等待队列 S.Q 中取出一个进程 P；<br> 进程 P 进入就绪队列；}</p>
<p>P、V 操作实现互斥模型：<br>type def semaphore；<br>semaphore S=1；<br>PROC1 PROC2<br>P（S）； P（S）；<br> critical section critical section<br>V（S）； V（S）；<br> remainder section remainder section<br>P、V 操作实现同步模型：<br>type def semaphore；<br>semaphore S=0；<br>PROC1 PROC2<br> P（S）；<br> produce data； consume data；<br>V（S）；<br> remainder section remainder section</p>
</blockquote>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p><strong>管程：</strong>一个管程定义了一个数据结构和能为并发进程所运行的一组操作，这组操作能同步进程和改变管程中的数据。</p>
<h3 id="经典的同步问题"><a href="#经典的同步问题" class="headerlink" title="经典的同步问题"></a>经典的同步问题</h3><ul>
<li><strong>生产者-消费者问题</strong></li>
<li><strong>读者-写者问题</strong></li>
<li><strong>哲学家进餐问题</strong></li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p><strong>死锁：</strong></p>
<blockquote>
<p>系统中两个或两个以上的进程无限期地相互等待永远不会发生的条件，系统处于一种停滞状态，这种情况称为死锁。</p>
</blockquote>
<p><strong>死锁产生的原因：</strong></p>
<ul>
<li>进程推进顺序不当</li>
<li>对互斥资源的分配不当</li>
</ul>
<p><strong>产生死锁的四个必要条件：</strong></p>
<ul>
<li>互斥条件：任一时刻只允许一个进程使用资源。</li>
<li>非剥夺条件：进程已经占用的资源，不会被强制剥夺。</li>
<li>占用并请求条件：进程占有部分资源，并申请更多的资源，且不会主动释放已经占有的资源。</li>
<li>循环等待：请求资源的进程形成了循环。</li>
</ul>
<p><strong>死锁的处理策略：</strong></p>
<ul>
<li>忽略死锁。</li>
<li>锁的检测与恢复。</li>
<li>死锁的<strong>避免</strong>。</li>
<li>死锁的<strong>预防</strong>。</li>
</ul>
<p><strong>死锁预防：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">条件</th>
<th style="text-align:center">方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">互斥</td>
<td style="text-align:center">虚拟设备假脱机</td>
</tr>
<tr>
<td style="text-align:center">占有并等待</td>
<td style="text-align:center">一次分配全部资源</td>
</tr>
<tr>
<td style="text-align:center">非剥夺</td>
<td style="text-align:center">主动放弃</td>
</tr>
<tr>
<td style="text-align:center">循环等待</td>
<td style="text-align:center">有序分配资源</td>
</tr>
</tbody>
</table>
<p><strong>死锁避免：</strong></p>
<ul>
<li>安全状态</li>
<li>不安全状态</li>
</ul>
<p><strong>银行家算法：</strong>（实际系统中难以实现，很难事先声明需要多少资源）</p>
<blockquote>
<p>银行家算法问题描述是：一个银行家把他的固定资金借给若干顾客，使这些顾客能满足对资金的要求又能完成其交易，也使银行家可以收回全部的现金。只要不出现一个顾客借走所有资金后还不够、还需要借贷。则银行家的资金应是安全的，银行家需要一个算法保证借出去的资金在有限时间内可收回。</p>
</blockquote>
<h3 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h3><p><strong>死锁的检测与解除：</strong></p>
<ul>
<li>资源分配图算法</li>
<li>资源矩阵算法</li>
</ul>
<p><strong>死锁的解除：</strong></p>
<ul>
<li>资源剥夺法</li>
<li>进程撤销法</li>
<li>进程回退法</li>
<li>重新启动系统</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【笔记】一、操作系统概述]]></title>
      <url>/2017/08/11/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%80%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h2 id="操作系统的概念、特征、功能和提供的服务"><a href="#操作系统的概念、特征、功能和提供的服务" class="headerlink" title="操作系统的概念、特征、功能和提供的服务"></a>操作系统的概念、特征、功能和提供的服务</h2><h3 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h3><p>操作系统是控制和管理计算机软、硬件资源，以尽可能合理、高效的方法为<br>不同用户及其应用程序提供服务的一种系统程序。（即操作系统是一个软件）</p>
<ul>
<li>从用户使用角度看，既可以直接用命令控制，也可以通过系统调用编程实现。（人机交互桥梁）</li>
<li>从资源管理的角度来看，操作系统提高系统资源的利用率。（软硬件的管理者）</li>
<li>从发展的角度看，操作系统是一台虚拟机，它是计算机硬件的首次扩充，又是扩展机。</li>
</ul>
<h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><ul>
<li>并发（最基本特征）</li>
<li>共享</li>
<li>虚拟</li>
<li>不确定性</li>
</ul>
<p>注：并发是操作系统最基本的，后三点都是由并发引起的</p>
<h3 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3><ul>
<li>进程管理</li>
<li>存储管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
<h3 id="操作系统所能提供的服务"><a href="#操作系统所能提供的服务" class="headerlink" title="操作系统所能提供的服务"></a>操作系统所能提供的服务</h3><p>命令控制接口：命令行，GUI，脚本（批处理），NUI（nature user interface[如：语音识别]）<br>系统调用：创建、打开、读、写、关闭、删除</p>
<p>API（Application Programming Interface）是多个系统调用和部分代码的综合，比系统调用功能更加强大（高，有多个变种）</p>
<h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h2><h3 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h3><ul>
<li>大型计算机、巨型计算机</li>
<li>军用计算机、工业控制计算机能实时响应</li>
<li>嵌入式计算机要求精简、功能专一</li>
<li>便携式设备要求省电，电池持续耐力强</li>
</ul>
<h3 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h3><ul>
<li>单用户操作系统</li>
<li>批处理操作系统：单道批处理；多道批处理。脱机；联机</li>
<li>分时操作系统</li>
<li>实时系统：硬实时；软实时</li>
<li>网络操作系统</li>
<li>分布式操作系统</li>
<li>并行操作系统</li>
</ul>
<h2 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h2><h3 id="内核态与用户态"><a href="#内核态与用户态" class="headerlink" title="内核态与用户态"></a>内核态与用户态</h3><ul>
<li>操作系统运行的状态（特权指令：只允许在内核态下使用）</li>
<li>用户代码运行的状态（访管指令：由用户态进入到内核态时使用）</li>
</ul>
<p>注：任何一条系统调用的第一条指令都是访管指令，陷入到内核区</p>
<h3 id="中断、异常"><a href="#中断、异常" class="headerlink" title="中断、异常"></a>中断、异常</h3><ul>
<li>中断处理异步事件</li>
<li>异常（故障、<strong>陷阱</strong>、中止）（是一种软中断）</li>
</ul>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><ul>
<li>陷入机制（访管指令）</li>
<li>内核态</li>
</ul>
<p>现代操作系统除了提供直接使用系统调用指令的接口外，通常的做法是提供一套方便、实用的应用程序函数库（又称为应用程序设计接口 API）。这些函数从应用的较高层面重新封装了系统调用，一方面屏蔽了复杂的系统调用传参问题，另一方面是高级语言接口，有助于快速开发。还有的系统在更高层面提供了系统程序设计的模板库和类库。</p>
<h2 id="操作系统体系结构"><a href="#操作系统体系结构" class="headerlink" title="操作系统体系结构"></a>操作系统体系结构</h2><ul>
<li>整体式（无结构）</li>
<li>层次式</li>
<li>微内核（客户/服务器）</li>
<li>模块式（面向对象）</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python（一）基础篇之【数据类型】]]></title>
      <url>/2017/08/11/Python%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E3%80%90%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%91/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><img src="http://upload-images.jianshu.io/upload_images/4101271-2910ac26266ef0ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>“Welcome to Hexo! This is your very first post.”<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">


<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="http://upload-images.jianshu.io/upload_images/4101271-2910ac26266ef0ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="数据类型的分类"><a href="#数据类型的分类" class="headerlink" title="数据类型的分类"></a>数据类型的分类</h2><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>Python Number 数据类型用于存储数值。<br>数据类型是不允许改变的,这就意味着如果改变 Number 数据类型的值，将重新分配内存空间。</p>
<h3 id="int"><a href="#int" class="headerlink" title="int"></a>int</h3><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>定义：它是一个有序的字符的集合，用于存储和表示基本的文本信息。</p>
<h3 id="独特特性"><a href="#独特特性" class="headerlink" title="独特特性"></a>独特特性</h3><ul>
<li>不可变性：字符串一旦创建，则不可以修改。一旦修改或者拼接，都会造成重新生成字符串，则要赋予一个新的值。</li>
</ul>
<h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p><strong>1.格式化操作符：%</strong></p>
<pre><code>格式：%[(name)][flags][width].[precision]typecode
内涵：
    (name)      可选，用于选择指定的key
    flags          可选，可供选择的值有:
                 +       右对齐；正数前加正好，负数前加负号；
                 -        左对齐；正数前无符号，负数前加负号；
</code></pre><p> 格式：%[(name)][flags][width].[precision]typecode<br>内涵：<br>    (name)      可选，用于选择指定的key<br>    flags          可选，可供选择的值有:</p>
<pre><code>+       右对齐；正数前加正好，负数前加负号；
-        左对齐；正数前无符号，负数前加负号；
</code></pre><p> <code>格式：%[(name)][flags][width].[precision]typecode</code><br> <code>格式：%[(name)][flags][width].[precision]typecode</code><br> <code>格式：%[(name)][flags][width].[precision]typecode</code><br> <code>格式：%[(name)][flags][width].[precision]typecode</code><br> <code>格式：%[(name)][flags][width].[precision]typecode</code></p>
<h3 id="字符串的内置方法"><a href="#字符串的内置方法" class="headerlink" title="字符串的内置方法"></a>字符串的内置方法</h3><h2 id="列表-元组"><a href="#列表-元组" class="headerlink" title="列表 | 元组"></a>列表 | 元组</h2><h2 id="字典-集合"><a href="#字典-集合" class="headerlink" title="字典 | 集合"></a>字典 | 集合</h2></the>]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
