<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[【笔记】一、操作系统概述]]></title>
      <url>/2017/08/11/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%80%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h2 id="操作系统的概念、特征、功能和提供的服务"><a href="#操作系统的概念、特征、功能和提供的服务" class="headerlink" title="操作系统的概念、特征、功能和提供的服务"></a>操作系统的概念、特征、功能和提供的服务</h2><h3 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h3><p>操作系统是控制和管理计算机软、硬件资源，以尽可能合理、高效的方法为<br>不同用户及其应用程序提供服务的一种系统程序。（即操作系统是一个软件）</p>
<ul>
<li>从用户使用角度看，既可以直接用命令控制，也可以通过系统调用编程实现。（人机交互桥梁）</li>
<li>从资源管理的角度来看，操作系统提高系统资源的利用率。（软硬件的管理者）</li>
<li>从发展的角度看，操作系统是一台虚拟机，它是计算机硬件的首次扩充，又是扩展机。</li>
</ul>
<h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><ul>
<li>并发（最基本特征）</li>
<li>共享</li>
<li>虚拟</li>
<li>不确定性</li>
</ul>
<p>注：并发是操作系统最基本的，后三点都是由并发引起的</p>
<h3 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3><ul>
<li>进程管理</li>
<li>存储管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
<h3 id="操作系统所能提供的服务"><a href="#操作系统所能提供的服务" class="headerlink" title="操作系统所能提供的服务"></a>操作系统所能提供的服务</h3><p>命令控制接口：命令行，GUI，脚本（批处理），NUI（nature user interface[如：语音识别]）<br>系统调用：创建、打开、读、写、关闭、删除</p>
<p>API（Application Programming Interface）是多个系统调用和部分代码的综合，比系统调用功能更加强大（高，有多个变种）</p>
<h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h2><h3 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h3><ul>
<li>大型计算机、巨型计算机</li>
<li>军用计算机、工业控制计算机能实时响应</li>
<li>嵌入式计算机要求精简、功能专一</li>
<li>便携式设备要求省电，电池持续耐力强</li>
</ul>
<h3 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h3><ul>
<li>单用户操作系统</li>
<li>批处理操作系统：单道批处理；多道批处理。脱机；联机</li>
<li>分时操作系统</li>
<li>实时系统：硬实时；软实时</li>
<li>网络操作系统</li>
<li>分布式操作系统</li>
<li>并行操作系统</li>
</ul>
<h2 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h2><h3 id="内核态与用户态"><a href="#内核态与用户态" class="headerlink" title="内核态与用户态"></a>内核态与用户态</h3><ul>
<li>操作系统运行的状态（特权指令：只允许在内核态下使用）</li>
<li>用户代码运行的状态（访管指令：由用户态进入到内核态时使用）</li>
</ul>
<p>注：任何一条系统调用的第一条指令都是访管指令，陷入到内核区</p>
<h3 id="中断、异常"><a href="#中断、异常" class="headerlink" title="中断、异常"></a>中断、异常</h3><ul>
<li>中断处理异步事件</li>
<li>异常（故障、<strong>陷阱</strong>、中止）（是一种软中断）</li>
</ul>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><ul>
<li>陷入机制（访管指令）</li>
<li>内核态</li>
</ul>
<p>现代操作系统除了提供直接使用系统调用指令的接口外，通常的做法是提供一套方便、实用的应用程序函数库（又称为应用程序设计接口 API）。这些函数从应用的较高层面重新封装了系统调用，一方面屏蔽了复杂的系统调用传参问题，另一方面是高级语言接口，有助于快速开发。还有的系统在更高层面提供了系统程序设计的模板库和类库。</p>
<h2 id="操作系统体系结构"><a href="#操作系统体系结构" class="headerlink" title="操作系统体系结构"></a>操作系统体系结构</h2><ul>
<li>整体式（无结构）</li>
<li>层次式</li>
<li>微内核（客户/服务器）</li>
<li>模块式（面向对象）</li>
</ul>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统原理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【文摘】中国最美现代化诗]]></title>
      <url>/2017/08/11/%E3%80%90%E6%96%87%E6%91%98%E3%80%91%E4%B8%AD%E5%9B%BD%E6%9C%80%E7%BE%8E%E7%8E%B0%E4%BB%A3%E5%8C%96%E8%AF%97/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><img src="http://upload-images.jianshu.io/upload_images/2153794-ceaab16082d93665.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="《再别康桥》————徐志摩"><a href="#《再别康桥》————徐志摩" class="headerlink" title="《再别康桥》————徐志摩"></a>《再别康桥》————徐志摩</h2><blockquote>
<p>轻轻的我走了，<br>正如我轻轻的来；<br>我轻轻的招手，<br>作别西天的云彩。</p>
<p>那河畔的金柳，<br>是夕阳中的新娘；<br>波光里的艳影，<br>在我的心头荡漾。</p>
<p>软泥上的青荇，<br>油油的在水底招摇；<br>在康河的柔波里，<br>我甘心做一条水草！</p>
<p>那榆荫下的一潭，<br>不是清泉，是天上虹<br>揉碎在浮藻间，<br>沉淀着彩虹似的梦。</p>
<p>寻梦？撑一支长蒿，<br>向青草更青处漫溯，<br>满载一船星辉，<br>在星辉斑斓里放歌。</p>
<p>但我不能放歌，<br>悄悄是别离的笙箫；<br>夏虫也为我沉默，<br>沉默是今晚的康桥！<br>悄悄的我走了，<br>正如我悄悄的来；<br>我挥一挥衣袖，<br>不带走一片云彩。</p>
</blockquote>
</the>]]></content>
      
        <categories>
            
            <category> 文摘 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Python（一）基础篇之【数据类型】]]></title>
      <url>/2017/08/11/Python%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E3%80%90%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%91/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><img src="http://upload-images.jianshu.io/upload_images/4101271-2910ac26266ef0ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>“Welcome to Hexo! This is your very first post.”<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">


<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="http://upload-images.jianshu.io/upload_images/4101271-2910ac26266ef0ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="数据类型的分类"><a href="#数据类型的分类" class="headerlink" title="数据类型的分类"></a>数据类型的分类</h2><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>Python Number 数据类型用于存储数值。<br>数据类型是不允许改变的,这就意味着如果改变 Number 数据类型的值，将重新分配内存空间。</p>
<h3 id="int"><a href="#int" class="headerlink" title="int"></a>int</h3><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>定义：它是一个有序的字符的集合，用于存储和表示基本的文本信息。</p>
<h3 id="独特特性"><a href="#独特特性" class="headerlink" title="独特特性"></a>独特特性</h3><ul>
<li>不可变性：字符串一旦创建，则不可以修改。一旦修改或者拼接，都会造成重新生成字符串，则要赋予一个新的值。</li>
</ul>
<h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p><strong>1.格式化操作符：%</strong></p>
<pre><code>格式：%[(name)][flags][width].[precision]typecode
内涵：
    (name)      可选，用于选择指定的key
    flags          可选，可供选择的值有:
                 +       右对齐；正数前加正好，负数前加负号；
                 -        左对齐；正数前无符号，负数前加负号；
</code></pre><p> 格式：%[(name)][flags][width].[precision]typecode<br>内涵：<br>    (name)      可选，用于选择指定的key<br>    flags          可选，可供选择的值有:</p>
<pre><code>+       右对齐；正数前加正好，负数前加负号；
-        左对齐；正数前无符号，负数前加负号；
</code></pre><p> <code>格式：%[(name)][flags][width].[precision]typecode</code><br> <code>格式：%[(name)][flags][width].[precision]typecode</code><br> <code>格式：%[(name)][flags][width].[precision]typecode</code><br> <code>格式：%[(name)][flags][width].[precision]typecode</code><br> <code>格式：%[(name)][flags][width].[precision]typecode</code></p>
<h3 id="字符串的内置方法"><a href="#字符串的内置方法" class="headerlink" title="字符串的内置方法"></a>字符串的内置方法</h3><h2 id="列表-元组"><a href="#列表-元组" class="headerlink" title="列表 | 元组"></a>列表 | 元组</h2><h2 id="字典-集合"><a href="#字典-集合" class="headerlink" title="字典 | 集合"></a>字典 | 集合</h2></the>]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试100道题]]></title>
      <url>/2017/08/10/%E9%9D%A2%E8%AF%95100%E9%81%93%E9%A2%98/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>header 1</th>
<th>header 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>row 1 col 1</td>
<td>row 1 col 2</td>
</tr>
<tr>
<td>row 2 col 1</td>
<td>row 2 col 2</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>到目前为止，当我们的程序涉及到数据库相关操作时，我们一般都会这么搞：</p>
<ul>
<li>创建数据库，设计表结构和字段 使用 MySQLdb </li>
<li>来连接数据库，并编写数据访问层代码</li>
<li>业务逻辑层去调用数据访问层执行数据库操作</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">import pymysql</div><div class="line">    </div><div class="line">    </div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">SqlHelper</span>(<span class="title">object</span>):</span></div><div class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></div><div class="line">                <span class="comment"># 读取配置文件</span></div><div class="line">                <span class="keyword">self</span>.connect()</div><div class="line">    </div><div class="line">            <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></div><div class="line">                <span class="keyword">self</span>.conn = pymysql.connect(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">3306</span>, user=<span class="string">'root'</span>, passwd=<span class="string">'123456'</span>, db=<span class="string">'sms'</span>, charset=<span class="string">'utf8'</span>)</div><div class="line">                <span class="keyword">self</span>.cursor = <span class="keyword">self</span>.conn.cursor(cursor=pymysql.cursors.DictCursor)</div><div class="line">        </div><div class="line">            <span class="function"><span class="keyword">def</span> <span class="title">get_list</span><span class="params">(<span class="keyword">self</span>, sql, args)</span></span><span class="symbol">:</span></div><div class="line">                <span class="keyword">self</span>.cursor.execute(sql, args)</div><div class="line">                result = <span class="keyword">self</span>.cursor.fetchall()</div><div class="line">                <span class="keyword">return</span> result</div><div class="line">        </div><div class="line">            <span class="function"><span class="keyword">def</span> <span class="title">get_one</span><span class="params">(<span class="keyword">self</span>, sql, args)</span></span><span class="symbol">:</span></div><div class="line">                <span class="keyword">self</span>.cursor.execute(sql, args)</div><div class="line">                result = <span class="keyword">self</span>.cursor.fetchone()</div><div class="line">                <span class="keyword">return</span> result</div><div class="line">        </div><div class="line">            <span class="function"><span class="keyword">def</span> <span class="title">modify</span><span class="params">(<span class="keyword">self</span>, sql, args)</span></span><span class="symbol">:</span></div><div class="line">                <span class="keyword">self</span>.cursor.execute(sql, args)</div><div class="line">                <span class="keyword">self</span>.conn.commit()</div><div class="line">        </div><div class="line">            <span class="function"><span class="keyword">def</span> <span class="title">multiple_modify</span><span class="params">(<span class="keyword">self</span>, sql, args)</span></span><span class="symbol">:</span></div><div class="line">                <span class="comment"># self.cursor.executemany('insert into bd(id,name)values(%s,%s)',[(1,'alex'),(2,'eric')])</span></div><div class="line">                <span class="keyword">self</span>.cursor.executemany(sql, args)</div><div class="line">                <span class="keyword">self</span>.conn.commit()</div><div class="line">        </div><div class="line">            <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(<span class="keyword">self</span>, sql, args)</span></span><span class="symbol">:</span></div><div class="line">                <span class="keyword">self</span>.cursor.execute(sql, args)</div><div class="line">                <span class="keyword">self</span>.conn.commit()</div><div class="line">                <span class="keyword">return</span> <span class="keyword">self</span>.cursor.lastrowid</div><div class="line">        </div><div class="line">            <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></div><div class="line">                <span class="keyword">self</span>.cursor.close()</div><div class="line">                <span class="keyword">self</span>.conn.close()</div></pre></td></tr></table></figure>
<p>django为使用一种新的方式，即：关系对象映射（Object Relational Mapping，简称ORM）。<br>django中遵循 Code Frist 的原则，即：根据代码中定义的类来自动生成数据库表。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[RabbitMQ原理介绍及安装部署]]></title>
      <url>/2017/08/10/RabbitMQ%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RabbitMQ 是一个用 Erlang 语言开发的 AMQP 开源实现。AMQP（Advanced Message Queue Protocol），高级消息队列协议，是异步消息处理领域的一个公开标准，主要由 Cisco、RedHat 等联合制定。而 RabbitMQ 就是 AMQP 的一个开源实现，由 RabbitMQ Technologies Ltd 公司开发并提供商业支持。</p>
<p>RabbitMQ 主要应用于大型系统中不同的应用或者子系统之间的通信，通过分隔数据的发送和接收来解耦应用。</p>
<h2 id="一条消息的“一生”"><a href="#一条消息的“一生”" class="headerlink" title="一条消息的“一生”"></a>一条消息的“一生”</h2><p>在对 RabbitMQ 进行更进一步的介绍之前，先让我们来看一看在 RabbitMQ 中，一条消息，从生产者到消费者完整的轨迹。</p>
<p>当生产者发布一条消息时，首先跟 RabbitMQ 建立连接（channel），通过该连接将想要发布的消息发送到交换器（exchange）上。交换器通过特定的路由规则（routing_key），将消息发送到某个队列（queue）。RabbitMQ 会监控该队列，一旦发现有消费者订阅了该队列，就将消息发送给消费者进行处理，然后将该消息从队列中删除。</p>
<p>需要注意的是，这里提到的生产者和消费者只是消息发送和接收的概念体现，每个客户端都可以是消费者或生产者。</p>
<p>接下来，对上面涉及到的一些重要的概念进行进一步的介绍。</p>
<h2 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h2><p>channel，是消费者或生产者与 RabbitMQ 之间的一条连接，本质上是 TCP 连接中的一个虚拟连接。在 RabbitMQ 中，消息的发送和接收、队列的订阅等操作都是通过信道完成的。</p>
<p>之所以选择信道，而不是在 TCP 连接上进行命令的发送，主要是基于性能的考虑。在操作系统中，建立和销毁 TCP 连接的开销是很昂贵的。而且，同一时刻，操作系统对于 TCP 连接的数量也是有限制的，很容易成为性能的瓶颈。而采用信道就不会有这种问题，可以在一个 TCP 连接中，任意的创建多条信道。</p>
<h2 id="路由键"><a href="#路由键" class="headerlink" title="路由键"></a>路由键</h2><p>routing_key，是一条特定的规则，决定了消息将要被发送到哪个队列。每条消息在发布的时候，都需要指定自己的 routing_key。</p>
<p>RabbitMQ 通过路由键实现了队列和交换器之间的绑定。</p>
<h2 id="交换器"><a href="#交换器" class="headerlink" title="交换器"></a>交换器</h2><p>exchange，生产者将消息发送给交换器，然后由交换器根据路由规则，决定将消息发送到哪个队列。</p>
<p>交换器本质上只是一个名称和一个队列绑定列表，当消息被发布到交换器时，实际上是所连接的信道将消息上的路由键和交换器中的绑定列表做比较，然后路由消息</p>
<p>在 RabbitMQ 中，常用的交换器类型有三种：direct、fanout 和 topic。下面，对这三种类型的交换器做更进一步的介绍。</p>
<h3 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h3><p>如果消息中的路由键和某个队列的路由键匹配的话，就将消息发送给该队列。</p>
<p>RabbitMQ 默认实现了一个名称为空的 direct 交换器，当声明一个队列时，如果没有指定交换器，那么 RabbitMQ 会把该队列自动绑定到这个默认的交换器，并以队列名称作为路由键。</p>
<p>在 RabbitMQ 中，支持在一个交换器上的多个队列配置相同的路由键。也就是说，对于绑定到交换器 Exchang_A 上的队列 Queue_1 和 Queue_2，可以设置同一个 routing_key（假设为 key_test）。当设置了 routing_key 为 key_test 的消息 Message 被发布到 Exchang_A 上时，Exchang_A 会将 Message 同时发送给 Queue_1 和 Queue_2 两个队列。</p>
<h3 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h3><p>设置为 fanout 的交换器，会将消息发送给所有绑定到它身上的队列，类似于广播。</p>
<p>通常应用于需要对一条消息做不同反应的场景中。比如，在社交网站上，如果用户上传了一张照片，在更新用户相册的同时，还需要给用户一些积分奖励。那么这种情况，就可以使用 fanout 类型的交换器来实现。只需要将更新用户相册的队列和增加用户积分的队列绑定到同一个 fanout 交换器上即可。</p>
<h3 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h3><p>topic 类型的交换器，可以使来自不同源头的消息到达同一个队列，即支持在路由键中使用通配符。</p>
<p>在 RabbitMQ 中，<code>.</code> 把路由键分成多个部分，<code>*</code> 匹配特定位置的任意文本，<code>#</code> 则表示匹配所有规则。通过对这几种通配符的组合使用，就可以实现将不同来源的消息发送到同一个队列。比如，将 routing_key 设置为 <code>*.error</code> ，就可以将所有 routing_key 以 <code>.error</code> 结尾的消息发送到同一个队列</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>queue，生产者发布的消息最终到达的地方，同时消费者从队列中消费消息。</p>
<h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><p>消费者主要通过两种方式从队列中接收消息：使用 basic.consume 和 basic.get 命令。</p>
<p>当消费者使用 basic.consume 订阅了某个队列后，一旦有消息到达该队列，RabbitMQ 就将消息立即发送给消费者，然后等待下一条消息的到来。</p>
<p>如果消费者使用的是 basic.get 命令，只会从队列中获取单条消息，无法持续获取。假如队列中堆积了 5 条消息，使用 basic.get 命令只会获得最开始的那条消息，后面的 4 条消息无法获取。</p>
<p>如果一个队列有多个消费者进行订阅，RabbitMQ 采用轮询的方式将消息发送给某个消费者，每条消息只发送给一个消费者。</p>
<p>也就是说，如果消费者 A、B、C订阅了同一个队列，那么第一条消息会发送给 A，第二条发送给 B，第三条发送给 C，第四条发送给 A，···，以此类推。</p>
<p>当消息被消费者消费了之后，RabbitMQ 就将该消息从队列中删除。</p>
<p>那么 RabbitMQ 怎么知道消息被消费者成功消费了呢？这就涉及到了消息的确认机制。</p>
<h3 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h3><p>消费者接收到的每条消息都必须进行确认，如果消费者没有对消息进行确认，那么 RabbitMQ 不会将下一条消息发送给该消费者，直到其对消息进行了确认。如果在消费者向 RabbitMQ 发送确认之前，消费者与 RabbitMQ 之间的连接断开了，那么 RabbitMQ 会将该消息发送给其他的消费者。</p>
<p>主要有两种确认方式：使用 basic.ack 命令向 RabbitMQ 发送确认，或者在订阅队列时将 auto_ack 参数设置为 true。</p>
<p>需要注意的是，如果设置了 auto_ack 为 true，那么一旦消费者接收到了消息，RabbitMQ 就认为确认了消息，从而将消息从队列中删除。但是消费者接收到消息并不等同于成功处理了消息，如果在成功处理该条消息之前出现问题或者程序崩溃，由于此时 RabbitMQ 已经将消息从队列中删除了，那么就意味着这条消息丢失了。</p>
<h2 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h2><p>vhost，简化版的 RabbitMQ 服务器，每一个 vhost 拥有自己的交换器、队列和绑定。更重要的是，它拥有自己的权限，不同的 vhost 之间是隔离的。可以将 vhost 想象成物理服务器上的虚拟机。</p>
<p>RabbitMQ 中默认的虚拟主机为：“/”。</p>
<h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p>默认情况下，如果 RabbitMQ 进行了重启，那么队列、交换器和其中的消息都会丢失。如果想要你的数据在重启后不丢失，那么就需要对消息进行持久化设置。主要操作如下：</p>
<ul>
<li>将消息的投递模式（delivery mode）设置为 2（持久）。</li>
<li>将消息发送到持久化的交换器。</li>
<li>消息必须到达持久化的队列。</li>
</ul>
<p>RabbitMQ 是通过将消息写入磁盘中的持久化日志中的方式实现消息的持久化的。如果持久化队列中的某条消息被消费了，那么 RabbitMQ 会在持久化日志中将该消息标记为等待垃圾收集。</p>
<h2 id="管理-RabbitMQ"><a href="#管理-RabbitMQ" class="headerlink" title="管理 RabbitMQ"></a>管理 RabbitMQ</h2><p>前面的部分介绍了一些 RabbitMQ 中比较重要的概念和消息的相关知识，接下来介绍如何对 RabbitMQ 进行管理。</p>
<p>首先需要明确一个概念，通常提到的 RabbitMQ 节点，实际上指的是 RabbitMQ 应用和所在的 Erlang 节点。RabbitMQ 是 Erlang 应用程序的一种。</p>
<p>启动 RabbitMQ 通常使用 <code>rabbitmq-server</code>工具，但需要注意的是，使用该命令启动的包括 Erlang 节点和 RabbitMQ 应用。同时，还把 RabbitMQ 应用设置成了独立运行模式。</p>
<p>对于 RabbitMQ 应用的管理，通常使用 <code>rabbitmqctl</code> 工具：</p>
<ul>
<li>stop 参数：将本地节点干净的关闭，包括 RabbitMQ 应用和 Erlang 节点。同时，可以使用 <code>-n rabbit@hostname</code> 参数，关闭指定的远程节点。</li>
<li>stop_app 参数：只关闭 RabbitMQ 应用。</li>
<li>start_app 参数：只启动 RabbitMQ 应用。</li>
</ul>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>对于 RabbitMQ 的内建集群，主要用于完成两个设计目标：</p>
<ul>
<li>允许消费者和生产者在节点崩溃的情况下继续运行。</li>
<li>通过添加更多的节点来线性扩展消息通信吞吐量。</li>
</ul>
<p>在默认情况下，如果集群中某个节点崩溃了，那么在该节点上队列上的消息也就丢失了，因为 RabbitMQ 不会将节点上的队列复制到整个集群中。</p>
<p>不论是在单节点系统中还是集群，对于 RabbitMQ 节点来说，要么是内存节点，要么是磁盘节点。两者间的主要区别：</p>
<ul>
<li>内存节点：所有队列、交换器、绑定、用户、权限和 vhost 的元数据定义都只是存储在内存中。</li>
<li>磁盘节点：所有的元数据信息存储在磁盘中。对于单节点系统，只允许节点为磁盘节点。</li>
</ul>
<p>当在集群中声明交换器、队列和绑定时，这些操作会等到集群中所有节点都成功提交元数据后才返回。</p>
<p>在 RabbitMQ 集群中，要求至少有一个磁盘节点，当有节点加入或离开时，需要将该变更通知到至少一个磁盘节点。</p>
]]></content>
      
        
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/08/10/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
