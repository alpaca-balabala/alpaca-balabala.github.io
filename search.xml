<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[【笔记】Python基础篇（一）数据类型]]></title>
      <url>/2017/08/14/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91Python%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="http://upload-images.jianshu.io/upload_images/4101271-2910ac26266ef0ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><ul>
<li>变量存储在内存中的值。这就意味着在创建变量时会在内存中开辟一个空间。</li>
<li>基于变量的数据类型，解释器会分配指定内存，并决定什么数据可以被存储在内存中。</li>
<li>因此，变量可以指定不同的数据类型，这些变量可以存储整数，小数或字符。</li>
</ul>
<h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><ul>
<li>Python 中的变量赋值不需要类型声明。</li>
<li>每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。</li>
<li>每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</li>
<li>等号（=）用来给变量赋值。</li>
<li>等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。</li>
</ul>
<h3 id="多个变量赋值"><a href="#多个变量赋值" class="headerlink" title="多个变量赋值"></a>多个变量赋值</h3><p>Python允许你同时为多个变量赋值。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = b = c = <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">"john"</span></div></pre></td></tr></table></figure></p>
<p>以上实例，两个整型对象1和2的分配给变量 a 和 b，字符串对象 “john” 分配给变量 c。</p>
<h2 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h2><h3 id="数字（Numbers）"><a href="#数字（Numbers）" class="headerlink" title="数字（Numbers）"></a>数字（Numbers）</h3><ul>
<li>数字数据类型用于存储数值。</li>
<li>他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。</li>
</ul>
<p><strong>整型</strong><br>Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样。</p>
<p>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用<code>0x</code>前缀和0-9，a-f表示，例如：<code>0xff00</code>，<code>0xa5b4c3d2</code>，等等。</p>
<p><strong>浮点型</strong><br>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10<sup>9</sup>和12.3x10<sup>8</sup>是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10<sup>9</sup>就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。</p>
<p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。故浮点数不能直接比大小！</p>
<p><strong>布尔型</strong></p>
<ul>
<li>True</li>
<li>False</li>
</ul>
<p><strong>复数</strong><br>Python还支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型</p>
<h3 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h3><p><em>字符串或串(String)是由数字、字母、下划线组成的一串字符。<br>它是编程语言中表示文本的数据类型。</em></p>
<p>python的字串列表有2种取值顺序:</p>
<ul>
<li>从左到右索引默认0开始的，最大范围是字符串长度少1</li>
<li>从右到左索引默认-1开始的，最大范围是字符串开头</li>
</ul>
<p>如果你要实现从字符串中获取一段子字符串的话，可以使用变量 <code>[头下标:尾下标]</code>，就可以截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，<code>下标可以为空表示取到头或尾</code>。</p>
<p>加号<code>+</code>是字符串连接运算符，星号<code>*</code>是重复操作。</p>
<h3 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h3><ul>
<li>List（列表） 是 Python 中使用最频繁的数据类型。</li>
<li>列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。</li>
<li>列表用 <code>[ ]</code> 标识，是 python 最通用的复合数据类型。</li>
<li>列表中值的切割也可以用到变量 <code>[头下标:尾下标]</code> ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。</li>
<li>加号 <code>+</code> 是列表连接运算符，星号 <code>*</code> 是重复操作</li>
</ul>
<h3 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h3><ul>
<li>元组是另一个数据类型，类似于List（列表）。</li>
<li>元组用<code>()</code>标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。</li>
</ul>
<h3 id="字典（Dictionary）"><a href="#字典（Dictionary）" class="headerlink" title="字典（Dictionary）"></a>字典（Dictionary）</h3><ul>
<li>字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象结合，字典是无序的对象集合。</li>
<li>两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</li>
<li>字典用<code>{ }</code>标识。字典由索引(key)和它对应的值value组成。</li>
</ul>
<h3 id="集合（Sets）-非标准数据类型"><a href="#集合（Sets）-非标准数据类型" class="headerlink" title="集合（Sets）(非标准数据类型)"></a>集合（Sets）(非标准数据类型)</h3><ul>
<li>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</li>
<li>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作。</li>
<li>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。<strong><em>原因：key必须是【可哈希】的，而不可变对象均可哈希。如果是元组，其中只能包括不可变类型。</em></strong></li>
</ul>
<h2 id="其它数据类型"><a href="#其它数据类型" class="headerlink" title="其它数据类型"></a>其它数据类型</h2><p><strong>空值</strong><br>空值是Python里一个特殊的值，用<code>None</code>表示。<code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</p>
<h2 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h2><p><strong>按存值个数区分：</strong></p>
<table>
<thead>
<tr>
<th>标量/原子类型</th>
<th>数字、字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>容器类型</td>
<td>列表、元组、字典、集合</td>
</tr>
</tbody>
</table>
<p><strong>按可变不可变区分：</strong></p>
<table>
<thead>
<tr>
<th>可变</th>
<th>列表、字典、集合</th>
</tr>
</thead>
<tbody>
<tr>
<td>不可变</td>
<td>数字、字符串、元组</td>
</tr>
</tbody>
</table>
<p><strong>按访问顺序区分：</strong></p>
<table>
<thead>
<tr>
<th>直接访问</th>
<th>数字</th>
</tr>
</thead>
<tbody>
<tr>
<td>顺序访问（序列类型）</td>
<td>字符串、列表、元组</td>
</tr>
<tr>
<td>key值访问（映射类型）</td>
<td>字典</td>
</tr>
</tbody>
</table>
<h2 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h2><p><img src="../../../../images/2017-08-14/QQ截图20170814102641.png" alt=""></p>
<h2 id="标准类型操作符"><a href="#标准类型操作符" class="headerlink" title="标准类型操作符"></a>标准类型操作符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><img src="../../../../images/2017-08-14/QQ截图20170814095650.png" alt=""></p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p><img src="../../../../images/2017-08-14/QQ截图20170814100003.png" alt=""></p>
<h3 id="比较（关系）运算符"><a href="#比较（关系）运算符" class="headerlink" title="比较（关系）运算符"></a>比较（关系）运算符</h3><p><img src="../../../../images/2017-08-14/QQ截图20170814095854.png" alt=""></p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p><img src="../../../../images/2017-08-14/QQ截图20170814100058.png" alt=""></p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><img src="../../../../images/2017-08-14/QQ截图20170814100326.png" alt=""></p>
<h3 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h3><p><img src="../../../../images/2017-08-14/QQ截图20170814100352.png" alt=""></p>
<h3 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h3><p><img src="../../../../images/2017-08-14/QQ截图20170814100430.png" alt=""></p>
<p><strong>is 与 == 区别：</strong><br>is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = a       <span class="comment">#  b引用a，二者指向同一块内存地址</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b == a</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = a[:]    <span class="comment">#  尽管b的值与a相同，但切片操作返回一个新的对象</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b == a</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure></p>
<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p><img src="../../../../images/2017-08-14/QQ截图20170814101504.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【笔记】二、进程与线程]]></title>
      <url>/2017/08/12/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h3><ul>
<li>一个具有一定独立功能的程序对某个数据集合上的一次动态执行过程和资源分配过程</li>
<li>进程的元素：代码、数据、<strong>进程表</strong>（进程控制块） Code、Data、PT（<strong>PCB</strong>）</li>
<li>是<strong>资源分配的基本单位</strong></li>
</ul>
<h3 id="进程和程序的区别与联系"><a href="#进程和程序的区别与联系" class="headerlink" title="进程和程序的区别与联系"></a>进程和程序的区别与联系</h3><ul>
<li>进程是动态的，程序是静态的</li>
<li>进程是暂时的，程序是永久的</li>
<li>进程和程序的组成不同<ul>
<li>程序主要包含代码和数据</li>
<li>进程除了包含代码和数据以外，还有进程表</li>
</ul>
</li>
<li>进程和程序间有非常紧密的联系<ul>
<li>程序经过多次创建，可以对应不同的进程</li>
<li>一个进程通过系统调用，可以被多个程序所使用</li>
</ul>
</li>
</ul>
<h3 id="进程特征"><a href="#进程特征" class="headerlink" title="进程特征"></a>进程特征</h3><p>动态性、并发性、独立性、异步性（提高利用率）</p>
<h3 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h3><p><strong>状态：</strong></p>
<ul>
<li>运行状态（Running）</li>
<li>阻塞状态（Blocked）</li>
<li>就绪状态（Ready）</li>
</ul>
<p><strong>转换：</strong></p>
<ol>
<li>运行状态→阻塞状态</li>
<li>运行状态→就绪状态</li>
<li>就绪状态→运行状态</li>
<li>阻塞状态→就绪状态<br><img src="../../../../images/2017-08-12/QQ截图20170812125716.png" alt=""><br><img src="../../../../images/2017-08-12/QQ截图20170812130314.png" alt=""><br><img src="../../../../images/2017-08-12/QQ截图20170812130526.png" alt=""></li>
</ol>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p><strong>进程创建</strong></p>
<blockquote>
<p>进程创建原语的主要工作是：首先查找系统的 PCB 表，查询有无空的 PCB<br>表项，如有，则申请一个，并对其进程初始化。初始化的项目有进程标识符（PID）、进程状态和运行程序的起始地址等；如果申请不成功，则返回创建失败信息。创建完成后，将进程表插入到就绪队列中。</p>
</blockquote>
<p><strong>进程创建的典型事件</strong></p>
<ul>
<li>用户登录</li>
<li>作业调度</li>
<li>提供服务</li>
<li>应用请求</li>
</ul>
<p><strong>进程的创建过程</strong></p>
<ul>
<li>申请空白进程表</li>
<li>为新进程分配资源</li>
<li>初始化进程表</li>
<li>如果进程就绪队列能够接纳新进程， 便将新进程插入就绪队列</li>
</ul>
<p><strong>进程撤销</strong></p>
<blockquote>
<p>撤销原语的主要工作是：首先检查 PCB 链表，寻找所要撤销的进程是否存在。如果找到了相应的表项后，撤销原语就释放该进程占用的资源并回收对应的PCB 数据结构。如果被撤销的进程还有子进程，则进程撤销原语必须先撤销子进程的 PCB 并释放其所占用的资源。</p>
</blockquote>
<ul>
<li>正常结束（自愿的）</li>
<li>异常结束<ul>
<li>普通错误退出（自愿的）</li>
<li>致命错误退出（非自愿的）</li>
</ul>
</li>
<li>外界干预（非自愿的）</li>
</ul>
<p><strong>进程阻塞</strong></p>
<blockquote>
<p>进程阻塞原语的运行：先停止处理机并同时保存该进程的处理机现场。然后将阻塞进程插入到等待队列中，再将控制权交给调度程序，调度程序会按调度算法从就绪队列中选择一个进程投入运行。</p>
</blockquote>
<p><strong>进程唤醒</strong></p>
<blockquote>
<p>唤醒原语工作：将被唤醒的进程从相应的等待队列移出，并将其 PCB 中状<br>态置为就绪态，并将其送入就绪队列。此时，唤醒原语既可以从调用程序处直接返回，也可以转向进程调度程序，由调度程序来选择一个合适的进程去运行。</p>
<p>一个进程由运行状态转变为阻塞状态，是这个进程自己调用阻塞原语去完成<br>的，而进程由阻塞状态到就绪状态，却是另一个进程调用唤醒原语实现的，一般情况下，这个进程与被唤醒进程是具有一定相关性的并发进程。</p>
</blockquote>
<p><strong>引起进程阻塞和唤醒的事件</strong></p>
<ul>
<li>请求系统服务</li>
<li>启动某种操作</li>
<li>新数据尚未到达</li>
<li>无新工作可做</li>
</ul>
<p><strong>进程挂起</strong></p>
<blockquote>
<p>挂起原语工作：将进程交换到外存交换区挂起，释放其在内存中占用的资源，改写 PCB，返回系统。</p>
</blockquote>
<p><strong>进程激活</strong></p>
<blockquote>
<p>激活原语工作：将进程从外存交换区调入内存（需要重新申请内存），进行<br>内存重定位，改写 PCB 进程状态信息，内存分配信息，程序计数器等，返回激活原语调用处。当激活后的进程处于就绪状态时，返回后控制权将交还给调度程序，重新调度。</p>
</blockquote>
<h3 id="进程组织"><a href="#进程组织" class="headerlink" title="进程组织"></a>进程组织</h3><p><strong>进程实体</strong><br><em>程序、数据集合、进程控制块（PCB）</em></p>
<ul>
<li>程序：也称正文，描述进程所要完成的功能，特指二进制的指令代码。</li>
<li>数据集合：程序运行所需要的数据结构。包括常数，变量，堆，数据栈等。</li>
<li>进程控制块：进程控制块包含了进程的描述信息、控制信息和资源信息，是进程动态特性的集中反映。</li>
</ul>
<p><strong>进程控制块 PCB：进程表 PT</strong></p>
<ul>
<li>进程控制信息<br>—进程的基本信息<br>—处理机管理信息</li>
<li>进程内存资源分配</li>
<li>进程设备和文件的分配和使用情况</li>
</ul>
<p><strong>进程控制块的组织</strong><br><em>链表方式、索引方式</em><br><img src="../../../../images/2017-08-12/QQ截图20170812132715.png" alt=""></p>
<p><strong>进程通信</strong></p>
<ul>
<li>进程通信：进程间的信息交换工作称为进程间的通信</li>
<li>P、V 操作称为低级通信</li>
<li>高级通信方式可分为三大类：共享内存、消息传递、管道机制</li>
<li>UNIX 通信还有信号（Signal）机制</li>
<li>网络通信还有套接字（Socket）</li>
</ul>
<p><strong>线程概念和多线程模型</strong></p>
<ul>
<li>线程的引入<br><img src="../../../../images/2017-08-12/QQ截图20170812133149.png" alt=""></li>
<li>线程的属性<ul>
<li>轻型实体（容易创建和撤销）</li>
<li><strong>独立调度和分派的基本单位</strong></li>
<li>可并发执行</li>
<li>共享进程资源</li>
<li>适应硬件的发展</li>
</ul>
</li>
<li>线程表<br><img src="../../../../images/2017-08-12/QQ截图20170812150537.png" alt=""></li>
<li><p>线程实体</p>
<blockquote>
<p>线程是进程中的一个实体，它是操作系统进行<strong>独立调度和分派的基本单位</strong>，但<strong>不是资源分配的基本单位</strong>。<br><img src="../../../../images/2017-08-12/QQ截图20170812150553.png" alt=""></p>
</blockquote>
</li>
<li><p>线程实现方式：线程在具体实现时形式上又分为内核线程和用户线程。</p>
</li>
<li>内核线程<br><img src="../../../../images/2017-08-12/QQ截图20170812134748.png" alt=""></li>
<li>用户线程<br><img src="../../../../images/2017-08-12/QQ截图20170812134857.png" alt=""></li>
<li>多线程模型<br><img src="../../../../images/2017-08-12/QQ截图20170812134955.png" alt=""><br>注：轻量级进程——只含有一个线程的进程</li>
</ul>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="调度的基本概念"><a href="#调度的基本概念" class="headerlink" title="调度的基本概念"></a>调度的基本概念</h3><p><strong>调度的基本概念</strong></p>
<blockquote>
<p>进程的数量多于处理机的个数，竞争处理机。分配处理机的任务由进程调度<br>程序完成，由进程分派程序具体实行。用一定的算法，动态地把处理机分配给进程，使之能公平、合理和高效地运行。调度是分层次的。—个作业从提交开始，直到完成，往往要经历多级调度。</p>
</blockquote>
<p><img src="../../../../images/2017-08-12/QQ截图20170812135957.png" alt=""></p>
<p><strong>作业调度</strong></p>
<blockquote>
<p>作业调度又称宏观调度或高级调度。其主要任务是按一定的原则，对外存储器中处于后备状态的作业进行选择。</p>
</blockquote>
<p><strong>进程调度</strong></p>
<blockquote>
<p>进程调度又称微观调度，是指决定就绪队列中哪个进程将获得处理机，并实<br>际将处理机分配给该进程的操作。</p>
<p>进程调度是操作系统中最基本的调度。调度过程体现了现代操作系统将策略与机制分离的设计思想，调度考虑的是选择进程的算法，并将算法选择提供给用户使用；而<strong>分派程序</strong>是机制，它是直接进行处理机切换的操作者。</p>
</blockquote>
<p><del><strong>交换调度：</strong>交换调度又称中级调度。</del>（内存中研究的）</p>
<p><img src="../../../../images/2017-08-12/QQ截图20170812140517.png" alt=""></p>
<p><strong>调度目标和准则</strong></p>
<ul>
<li>公平性：确保每个进程都能公平地获得处理机的机会</li>
<li>高效性：尽可能使处理机的利用率达到 100%</li>
<li>响应时间：对交互式系统要求有符合用户习惯的响应时间</li>
<li>吞吐量：单位时间内批处理系统所能完成的工作量</li>
</ul>
<h3 id="调度的时机、切换和过程"><a href="#调度的时机、切换和过程" class="headerlink" title="调度的时机、切换和过程"></a>调度的时机、切换和过程</h3><p><strong>1. 引起进程调度的典型事件：</strong></p>
<ul>
<li>正在运行的进程发生某事件而不能再继续运行</li>
<li>运行中的进程因提出输入/输出请求而暂停运行</li>
<li>在进程通信或同步过程中运行了某种原语操作，如 P 操作等</li>
<li>在可抢先式调度中，有一个比当前进程优先级更高的进程进入就绪队列</li>
<li>在时间片轮转算法中，时间片用完。</li>
</ul>
<p><strong>2. 分派程序（dispatcher）：</strong></p>
<ul>
<li>分派程序完成进程的切换，是实际操作者。</li>
<li>上下文切换</li>
</ul>
<h3 id="调度的基本准则"><a href="#调度的基本准则" class="headerlink" title="调度的基本准则"></a>调度的基本准则</h3><p><strong>调度的基本准则包括：</strong>处理机利用率、吞吐量、周转时间<br><strong>调度的基本名词解释：</strong>后备时间、等待时间、响应时间、带权周转时间</p>
<h3 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a>调度方式</h3><ul>
<li>不可抢先方式</li>
<li>可抢先方式</li>
</ul>
<h3 id="典型调度算法"><a href="#典型调度算法" class="headerlink" title="典型调度算法"></a>典型调度算法</h3><ul>
<li>先来先服务（FCFS）</li>
<li>短作业或短进（线）程优先（SJF&amp;SPF）</li>
<li>时间片轮转调度算法（RR）</li>
<li>高优先级优先调度算法</li>
<li>高响应比优先调度（HRRN）算法<blockquote>
<p>响应比 Rp =（等待时间+预计运行时间）/ 预计运行时间 = 响应时间 / 预计运行时间</p>
</blockquote>
</li>
<li>多级反馈队列调度算法</li>
</ul>
<h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><h3 id="同步与互斥的基本概念"><a href="#同步与互斥的基本概念" class="headerlink" title="同步与互斥的基本概念"></a>同步与互斥的基本概念</h3><p><strong>基本概念：</strong></p>
<ul>
<li>间接相互制约：源于资源共享-<strong>互斥</strong>。</li>
<li>直接相互制约：源于进程合作-<strong>同步</strong>。</li>
<li><strong>临界资源</strong>：一次只允许一个进程使用的资源称为临界资源</li>
<li><strong>临界区</strong>：在每个进程中，访问临界资源的那段程序称为临界区</li>
</ul>
<p><strong>同步与互斥机制应遵循的准则：</strong></p>
<ul>
<li>空闲则进</li>
<li>遇忙等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ul>
<h3 id="实现临界区互斥的基本方法"><a href="#实现临界区互斥的基本方法" class="headerlink" title="实现临界区互斥的基本方法"></a>实现临界区互斥的基本方法</h3><ul>
<li><strong>软件实现方法</strong></li>
<li><strong>硬件实现方法</strong></li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量：信号量的值是可变的，由初始化和 P、V 操作来改变。</p>
<blockquote>
<p>P（S）操作的定义：<br>–S.Q； //表示申请一个资源<br>if (S.Q &lt; 0) //若没有空闲资源<br>{<br> 调用进程进入等待队列 S.Q；<br> 阻塞调用进程；<br>}<br>V（S）操作的定义：<br>++S.Q； //表示释放一个资源<br>if (S.Q &lt;= 0) //若有进程处于阻塞状态<br>{<br> 从等待队列 S.Q 中取出一个进程 P；<br> 进程 P 进入就绪队列；}</p>
<p>P、V 操作实现互斥模型：<br>type def semaphore；<br>semaphore S=1；<br>PROC1 PROC2<br>P（S）； P（S）；<br> critical section critical section<br>V（S）； V（S）；<br> remainder section remainder section<br>P、V 操作实现同步模型：<br>type def semaphore；<br>semaphore S=0；<br>PROC1 PROC2<br> P（S）；<br> produce data； consume data；<br>V（S）；<br> remainder section remainder section</p>
</blockquote>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p><strong>管程：</strong>一个管程定义了一个数据结构和能为并发进程所运行的一组操作，这组操作能同步进程和改变管程中的数据。</p>
<h3 id="经典的同步问题"><a href="#经典的同步问题" class="headerlink" title="经典的同步问题"></a>经典的同步问题</h3><ul>
<li><strong>生产者-消费者问题</strong></li>
<li><strong>读者-写者问题</strong></li>
<li><strong>哲学家进餐问题</strong></li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p><strong>死锁：</strong></p>
<blockquote>
<p>系统中两个或两个以上的进程无限期地相互等待永远不会发生的条件，系统处于一种停滞状态，这种情况称为死锁。</p>
</blockquote>
<p><strong>死锁产生的原因：</strong></p>
<ul>
<li>进程推进顺序不当</li>
<li>对互斥资源的分配不当</li>
</ul>
<p><strong>产生死锁的四个必要条件：</strong></p>
<ul>
<li>互斥条件：任一时刻只允许一个进程使用资源。</li>
<li>非剥夺条件：进程已经占用的资源，不会被强制剥夺。</li>
<li>占用并请求条件：进程占有部分资源，并申请更多的资源，且不会主动释放已经占有的资源。</li>
<li>循环等待：请求资源的进程形成了循环。</li>
</ul>
<p><strong>死锁的处理策略：</strong></p>
<ul>
<li>忽略死锁。</li>
<li>锁的检测与恢复。</li>
<li>死锁的<strong>避免</strong>。</li>
<li>死锁的<strong>预防</strong>。</li>
</ul>
<p><strong>死锁预防：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">条件</th>
<th style="text-align:center">方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">互斥</td>
<td style="text-align:center">虚拟设备假脱机</td>
</tr>
<tr>
<td style="text-align:center">占有并等待</td>
<td style="text-align:center">一次分配全部资源</td>
</tr>
<tr>
<td style="text-align:center">非剥夺</td>
<td style="text-align:center">主动放弃</td>
</tr>
<tr>
<td style="text-align:center">循环等待</td>
<td style="text-align:center">有序分配资源</td>
</tr>
</tbody>
</table>
<p><strong>死锁避免：</strong></p>
<ul>
<li>安全状态</li>
<li>不安全状态</li>
</ul>
<p><strong>银行家算法：</strong>（实际系统中难以实现，很难事先声明需要多少资源）</p>
<blockquote>
<p>银行家算法问题描述是：一个银行家把他的固定资金借给若干顾客，使这些顾客能满足对资金的要求又能完成其交易，也使银行家可以收回全部的现金。只要不出现一个顾客借走所有资金后还不够、还需要借贷。则银行家的资金应是安全的，银行家需要一个算法保证借出去的资金在有限时间内可收回。</p>
</blockquote>
<h3 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h3><p><strong>死锁的检测与解除：</strong></p>
<ul>
<li>资源分配图算法</li>
<li>资源矩阵算法</li>
</ul>
<p><strong>死锁的解除：</strong></p>
<ul>
<li>资源剥夺法</li>
<li>进程撤销法</li>
<li>进程回退法</li>
<li>重新启动系统</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【笔记】一、操作系统概述]]></title>
      <url>/2017/08/11/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%80%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h2 id="操作系统的概念、特征、功能和提供的服务"><a href="#操作系统的概念、特征、功能和提供的服务" class="headerlink" title="操作系统的概念、特征、功能和提供的服务"></a>操作系统的概念、特征、功能和提供的服务</h2><h3 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h3><p>操作系统是控制和管理计算机软、硬件资源，以尽可能合理、高效的方法为<br>不同用户及其应用程序提供服务的一种系统程序。（即操作系统是一个软件）</p>
<ul>
<li>从用户使用角度看，既可以直接用命令控制，也可以通过系统调用编程实现。（人机交互桥梁）</li>
<li>从资源管理的角度来看，操作系统提高系统资源的利用率。（软硬件的管理者）</li>
<li>从发展的角度看，操作系统是一台虚拟机，它是计算机硬件的首次扩充，又是扩展机。</li>
</ul>
<h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><ul>
<li>并发（最基本特征）</li>
<li>共享</li>
<li>虚拟</li>
<li>不确定性</li>
</ul>
<p>注：并发是操作系统最基本的，后三点都是由并发引起的</p>
<h3 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3><ul>
<li>进程管理</li>
<li>存储管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
<h3 id="操作系统所能提供的服务"><a href="#操作系统所能提供的服务" class="headerlink" title="操作系统所能提供的服务"></a>操作系统所能提供的服务</h3><p>命令控制接口：命令行，GUI，脚本（批处理），NUI（nature user interface[如：语音识别]）<br>系统调用：创建、打开、读、写、关闭、删除</p>
<p>API（Application Programming Interface）是多个系统调用和部分代码的综合，比系统调用功能更加强大（高，有多个变种）</p>
<h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h2><h3 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h3><ul>
<li>大型计算机、巨型计算机</li>
<li>军用计算机、工业控制计算机能实时响应</li>
<li>嵌入式计算机要求精简、功能专一</li>
<li>便携式设备要求省电，电池持续耐力强</li>
</ul>
<h3 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h3><ul>
<li>单用户操作系统</li>
<li>批处理操作系统：单道批处理；多道批处理。脱机；联机</li>
<li>分时操作系统</li>
<li>实时系统：硬实时；软实时</li>
<li>网络操作系统</li>
<li>分布式操作系统</li>
<li>并行操作系统</li>
</ul>
<h2 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h2><h3 id="内核态与用户态"><a href="#内核态与用户态" class="headerlink" title="内核态与用户态"></a>内核态与用户态</h3><ul>
<li>操作系统运行的状态（特权指令：只允许在内核态下使用）</li>
<li>用户代码运行的状态（访管指令：由用户态进入到内核态时使用）</li>
</ul>
<p>注：任何一条系统调用的第一条指令都是访管指令，陷入到内核区</p>
<h3 id="中断、异常"><a href="#中断、异常" class="headerlink" title="中断、异常"></a>中断、异常</h3><ul>
<li>中断处理异步事件</li>
<li>异常（故障、<strong>陷阱</strong>、中止）（是一种软中断）</li>
</ul>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><ul>
<li>陷入机制（访管指令）</li>
<li>内核态</li>
</ul>
<p>现代操作系统除了提供直接使用系统调用指令的接口外，通常的做法是提供一套方便、实用的应用程序函数库（又称为应用程序设计接口 API）。这些函数从应用的较高层面重新封装了系统调用，一方面屏蔽了复杂的系统调用传参问题，另一方面是高级语言接口，有助于快速开发。还有的系统在更高层面提供了系统程序设计的模板库和类库。</p>
<h2 id="操作系统体系结构"><a href="#操作系统体系结构" class="headerlink" title="操作系统体系结构"></a>操作系统体系结构</h2><ul>
<li>整体式（无结构）</li>
<li>层次式</li>
<li>微内核（客户/服务器）</li>
<li>模块式（面向对象）</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
